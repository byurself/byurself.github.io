<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RPC学习笔记与项目实战 | byu_rself</title><meta name="author" content="byu_rself"><meta name="copyright" content="byu_rself"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="RPC学习笔记与项目实战Guide哥RPC学习笔记 RPC简介什么是RPC？RPC（Remote Procedure Call） 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。 为什么要 RPC ？ 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们">
<meta property="og:type" content="article">
<meta property="og:title" content="RPC学习笔记与项目实战">
<meta property="og:url" content="https://byurself.github.io/byu_rself/58d29a67.html">
<meta property="og:site_name" content="byu_rself">
<meta property="og:description" content="RPC学习笔记与项目实战Guide哥RPC学习笔记 RPC简介什么是RPC？RPC（Remote Procedure Call） 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。 为什么要 RPC ？ 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://byurself.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2023-04-21T13:38:18.000Z">
<meta property="article:modified_time" content="2023-08-07T02:11:05.933Z">
<meta property="article:author" content="byu_rself">
<meta property="article:tag" content="RPC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://byurself.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/logo.jpg"><link rel="canonical" href="https://byurself.github.io/byu_rself/58d29a67.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: byu_rself","link":"链接: ","source":"来源: byu_rself","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RPC学习笔记与项目实战',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-07 10:11:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">577</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">104</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="byu_rself"><span class="site-name">byu_rself</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RPC学习笔记与项目实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-21T13:38:18.000Z" title="发表于 2023-04-21 21:38:18">2023-04-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-07T02:11:05.933Z" title="更新于 2023-08-07 10:11:05">2023-08-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/RPC/">RPC</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">22.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>81分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RPC学习笔记与项目实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="RPC学习笔记与项目实战"><a href="#RPC学习笔记与项目实战" class="headerlink" title="RPC学习笔记与项目实战"></a>RPC学习笔记与项目实战</h1><p><a target="_blank" rel="noopener" href="https://www.yuque.com/snailclimb/gsmusc">Guide哥RPC学习笔记</a></p>
<h2 id="RPC简介"><a href="#RPC简介" class="headerlink" title="RPC简介"></a>RPC简介</h2><h3 id="什么是RPC？"><a href="#什么是RPC？" class="headerlink" title="什么是RPC？"></a>什么是RPC？</h3><p><strong>RPC</strong>（Remote Procedure Call） 即<strong>远程过程调用</strong>，通过名字我们就能看出 RPC 关注的是<strong>远程调用</strong>而非本地调用。</p>
<p><strong>为什么要 RPC ？</strong> 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP 还是 UDP）、序列化方式等等方面。</p>
<p><strong>RPC 能帮助我们做什么呢？</strong>  简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且，我们不需要了解底层网络编程的具体细节。</p>
<p>举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。</p>
<p>一言蔽之：RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。</p>
<h3 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h3><p>RPC的核心功能由以下5个部分实现：</p>
<ol>
<li><strong>客户端（服务消费端）：</strong>调用远程方法的一端。</li>
<li><strong>客户端 Stub（桩）：</strong> 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。</li>
<li><strong>网络传输：</strong> 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最基本的 Socket 或者性能以及封装更加优秀的 Netty（推荐）。</li>
<li><strong>服务端 Stub（桩）：</strong>这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。</li>
<li><strong>服务端（服务提供端）：</strong>提供远程方法的一端。</li>
</ol>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/RPC%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" alt="RPC原理图"></p>
<p>执行流程：</p>
<ol>
<li>**服务消费端（client）:**以本地调用的方式调用远程服务；</li>
<li><strong>客户端 Stub（client stub）:</strong> 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：<code>RpcRequest</code>；</li>
<li><strong>客户端 Stub（client stub）:</strong> 找到远程服务的地址，并将消息发送到服务提供端；</li>
<li>**服务端 Stub（桩）:**收到消息将消息反序列化为 Java 对象: <code>RpcRequest</code>；</li>
<li>**服务端 Stub（桩）:**根据<code>RpcRequest</code>中的类、方法、方法参数等信息调用本地的方法；</li>
<li>**服务端 Stub（桩）:**得到方法执行结果并将组装成能够进行网络传输的消息体：<code>RpcResponse</code>（序列化）发送至消费方；</li>
<li>**客户端 Stub（client stub）:**接收到消息并将消息反序列化为 Java 对象:<code>RpcResponse </code>，这样也就得到了最终结果。</li>
</ol>
<h2 id="常见RPC框架"><a href="#常见RPC框架" class="headerlink" title="常见RPC框架"></a>常见RPC框架</h2><p>这里说的 RPC 框架指的是可以让客户端直接调用服务端方法，就像调用本地方法一样简单的框架，比如我下面介绍的 <strong>Dubbo</strong>、<strong>Motan</strong>、<strong>gRPC</strong>这些。  如果需要和 HTTP 协议打交道，解析和封装 HTTP 请求和响应。这类框架并不能算是“RPC 框架”，比如Feign。</p>
<h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/Dubbo.png" alt="Dubbo"></p>
<p>Apache Dubbo 是一款微服务框架，为大规模微服务实践提供高性能 RPC 通信、流量治理、可观测性等解决方案， 涵盖 Java、Golang 等多种语言 SDK 实现。</p>
<p>Dubbo 提供了从服务定义、服务发现、服务通信到流量管控等几乎所有的服务治理能力，支持 Triple 协议（基于 HTTP&#x2F;2 之上定义的下一代 RPC 通信协议）、应用级服务发现、Dubbo Mesh （Dubbo3 赋予了很多云原生友好的新特性）等特性。</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/7d56f751-63a9-4ee6-9834-a71121858d64.png" alt="7d56f751-63a9-4ee6-9834-a71121858d64"></p>
<p>Dubbo 是由阿里开源，后来加入了 Apache 。正是由于 Dubbo 的出现，才使得越来越多的公司开始使用以及接受分布式架构。</p>
<ul>
<li>Github：<a target="_blank" rel="noopener" href="https://github.com/apache/incubator-dubbo">https://github.com/apache/incubator-dubbo</a></li>
<li>官网：<a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/">https://dubbo.apache.org/zh/</a></li>
</ul>
<h3 id="Motan"><a href="#Motan" class="headerlink" title="Motan"></a>Motan</h3><p>Motan 是新浪微博开源的一款 RPC 框架，据说在新浪微博正支撑着千亿次调用。不过笔者倒是很少看到有公司使用，而且网上的资料也比较少。</p>
<p>很多人喜欢拿 Motan 和 Dubbo 作比较，毕竟都是国内大公司开源的。笔者在查阅了很多资料，以及简单查看了其源码之后发现：Motan 更像是一个精简版的 Dubbo，可能是借鉴了 Dubbo 的思想，Motan 的设计更加精简，功能更加纯粹。</p>
<p>不过，不推荐在实际项目中使用 Motan。如果要是公司实际使用的话，还是推荐 Dubbo ，其社区活跃度以及生态都要好很多。</p>
<ul>
<li>从 Motan 看 RPC 框架设计：<a target="_blank" rel="noopener" href="http://kriszhang.com/motan-rpc-impl/">http://kriszhang.com/motan-rpc-impl/</a></li>
<li>Motan 中文文档：<a target="_blank" rel="noopener" href="https://github.com/weibocom/motan/wiki/zh_overview">https://github.com/weibocom/motan/wiki/zh_overview</a></li>
</ul>
<h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/gRPC.png" alt="gRPC"></p>
<p>gRPC 是 Google 开源的一个高性能、通用的开源 RPC 框架。其由主要面向移动应用开发并基于 HTTP&#x2F;2 协议标准而设计（支持双向流、消息头压缩等功能，更加节省带宽），基于 ProtoBuf 序列化协议开发，并且支持众多开发语言。</p>
<p><strong>何谓 ProtoBuf？</strong> <a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf">ProtoBuf（ Protocol Buffer）</a> 是一种更加灵活、高效的数据格式，可用于通讯协议、数据存储等领域，基本支持所有主流编程语言且与平台无关。不过，通过 ProtoBuf 定义接口和数据类型还挺繁琐的，这是一个小问题。</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/2f96b290-3173-4807-a6b8-49ab1424a31e.png" alt="2f96b290-3173-4807-a6b8-49ab1424a31e"></p>
<p>不得不说，gRPC 的通信层的设计还是非常优秀的，<a target="_blank" rel="noopener" href="https://dubbogo.github.io/">Dubbo-go 3.0</a>  的通信层改进主要借鉴了 gRPC。</p>
<p>不过，gRPC 的设计导致其几乎没有服务治理能力。如果你想要解决这个问题的话，就需要依赖其他组件比如腾讯的 PolarisMesh（北极星）了。</p>
<ul>
<li>Github：<a target="_blank" rel="noopener" href="https://github.com/grpc/grpc">https://github.com/grpc/grpc</a></li>
<li>官网：<a target="_blank" rel="noopener" href="https://grpc.io/">https://grpc.io/</a></li>
</ul>
<h3 id="Thirft"><a href="#Thirft" class="headerlink" title="Thirft"></a>Thirft</h3><p>Apache Thrift 是 Facebook 开源的跨语言的 RPC 通信框架，目前已经捐献给 Apache 基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于 thrift 研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</p>
<p>Thrift支持多种不同的编程语言，包括C++、Java、Python、PHP、Ruby等（相比于 gRPC 支持的语言更多 ）。</p>
<ul>
<li>官网：<a target="_blank" rel="noopener" href="https://thrift.apache.org/">https://thrift.apache.org/</a></li>
<li>Thrift 简单介绍：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8f25d057a5a9">https://www.jianshu.com/p/8f25d057a5a9</a></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>gRPC 和 Thrift 虽然支持跨语言的 RPC 调用，但是它们只提供了最基本的 RPC 框架功能，缺乏一系列配套的服务化组件和服务治理功能的支撑。</p>
<p>Dubbo 不论是从功能完善程度、生态系统还是社区活跃度来说都是最优秀的。而且，Dubbo在国内有很多成功的案例比如当当网、滴滴等等，是一款经得起生产考验的成熟稳定的 RPC 框架。最重要的是你还能找到非常多的 Dubbo 参考资料，学习成本相对也较低。</p>
<p>下图展示了 Dubbo 的生态系统。</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/911676cf-9f1e-4b79-9d23-832aeab3af6d.png" alt="911676cf-9f1e-4b79-9d23-832aeab3af6d"></p>
<p>Dubbo 也是 Spring Cloud Alibaba 里面的一个组件。</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/86b79899-0d94-4277-88f2-1bc8199d2d82.png" alt="86b79899-0d94-4277-88f2-1bc8199d2d82"></p>
<p>但是，Dubbo 和 Motan 主要是给 Java 语言使用。虽然，Dubbo 和 Motan 目前也能兼容部分语言，但是不太推荐。如果需要跨多种语言调用的话，可以考虑使用 gRPC。</p>
<p>综上，如果是 Java 后端技术栈，并且你在纠结选择哪一种 RPC 框架的话，我推荐你考虑一下 Dubbo。</p>
<h2 id="如何自己实现一个RPC框架"><a href="#如何自己实现一个RPC框架" class="headerlink" title="如何自己实现一个RPC框架"></a>如何自己实现一个RPC框架</h2><p>像设计一个 RPC 框架&#x2F;消息队列这类问题在面试中还是非常常见的。这是一道你花点精力稍微准备一下就能回答上来的一个问题。如果你回答的比较好的话，那面试官肯定会对你印象非常不错！</p>
<p>消息队列的设计实际上和 RPC 框架&#x2F;非常类似，我这里就先拿 RPC 框架开涮。</p>
<h3 id="如何自己设计一个RPC框架"><a href="#如何自己设计一个RPC框架" class="headerlink" title="如何自己设计一个RPC框架"></a>如何自己设计一个RPC框架</h3><p><strong>一般情况下， RPC 框架不仅要提供服务发现功能，还要提供负载均衡、容错等功能，这样的 RPC 框架才算真正合格的。</strong></p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/RPC%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="RPC架构图"></p>
<p>从上图我们可以看出：<strong>服务提供端 Server 向注册中心注册服务，服务消费者 Client 通过注册中心拿到服务相关信息，然后再通过网络请求服务提供端 Server。</strong></p>
<p>作为 RPC 框架领域的佼佼者<a target="_blank" rel="noopener" href="https://github.com/apache/dubbo">Dubbo</a>的架构如下图所示,和我们上面画的大体也是差不多的。</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/Dubbo%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="Dubbo架构图"></p>
<p>下面我们再来看一个比较完整的 RPC 框架使用示意图如下：</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/06f58c75-1637-456b-bea9-a83060a62c01.png" alt="06f58c75-1637-456b-bea9-a83060a62c01"></p>
<p><strong>参考上面这张图，我们简单说一下设计一个最基本的 RPC 框架的思路或者说实现一个最基本的 RPC 框架需要哪些东西：</strong></p>
<h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>注册中心首先是要有的。比较推荐使用 Zookeeper 作为注册中心。当然了，你也可以使用 Nacos ，甚至是 Redis。</p>
<p>ZooKeeper 为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布&#x2F;订阅、负载均衡、命名服务、分布式协调&#x2F;通知、集群管理、Master 选举、分布式锁和分布式队列等功能。并且，ZooKeeper 将数据保存在内存中，性能是非常棒的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景）。</p>
<p>关于 ZooKeeper 的更多介绍可以查看这篇文章：<a target="_blank" rel="noopener" href="https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro.html">《ZooKeeper 相关概念总结》</a></p>
<p>当然了，如果你想通过文件来存储服务地址的话也是没问题的，不过性能会比较差。</p>
<p>注册中心负责服务地址的注册与查找，相当于目录服务。 服务端启动的时候将服务名称及其对应的地址(ip+port)注册到注册中心，服务消费端根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。</p>
<p>我们再来结合 Dubbo 的架构图来理解一下</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/d0ba7446-455a-40e8-bba2-58f03634860d.png" alt="d0ba7446-455a-40e8-bba2-58f03634860d"></p>
<p>上述节点简单说明：</p>
<ul>
<li><strong>Provider：</strong> 暴露服务的服务提供方</li>
<li><strong>Consumer：</strong> 调用远程服务的服务消费方</li>
<li><strong>Registry：</strong> 服务注册与发现的注册中心</li>
<li><strong>Monitor：</strong> 统计服务的调用次数和调用时间的监控中心</li>
<li><strong>Container：</strong> 服务运行容器</li>
</ul>
<p>调用关系说明：</p>
<ol>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<h4 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h4><p><strong>既然我们要调用远程的方法，就要发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务提供端。</strong></p>
<p>网络传输具体实现你可以使用 <strong>Socket</strong> （ Java 中最原始、最基础的网络通信方式。但是，Socket 是阻塞 IO、性能低并且功能单一）。</p>
<p>你也可以使用同步非阻塞的 I&#x2F;O 模型 <strong>NIO</strong> ，但是用它来进行网络编程真的太麻烦了。不过没关系，你可以使用基于 NIO 的网络编程框架 <strong>Netty</strong> ，它将是你最好的选择！</p>
<p>先简单介绍一下 <strong>Netty</strong> ，后面的文章中会详细介绍到</p>
<ol>
<li><strong>Netty</strong> 是一个基于 NIO 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。</li>
<li>它极大地简化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。</li>
<li>支持多种协议如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。</li>
</ol>
<h4 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h4><p>要在网络传输数据就要涉及到<strong>序列化</strong>。<strong>为什么需要序列化和反序列化呢？</strong>  </p>
<p>因为网络传输的数据必须是<strong>二进制</strong>的。因此，我们的 Java 对象没办法直接在网络中传输。为了能够让 Java 对象在网络中传输我们需要将其<strong>序列化</strong>为二进制的数据。我们最终需要的还是目标 Java 对象，因此我们还要将二进制的数据“解析”为目标 Java 对象，也就是对二进制数据再进行一次<strong>反序列化</strong>。</p>
<p>另外，不仅网络传输的时候需要用到序列化和反序列化，将对象存储到文件、数据库等场景都需要用到序列化和反序列化。</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="序列化和反序列化"></p>
<p>JDK 自带的序列化，只需实现 <code>java.io.Serializable</code>接口即可，不过这种方式不推荐，因为不支持跨语言调用并且性能比较差。</p>
<p>现在比较常用序列化的有 <strong>hessian</strong>、<strong>kryo</strong>、<strong>protostuff</strong> ……。我会在下一篇文章中简单对比一下这些序列化方式。</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理也是需要的。很多人可能不清楚为啥需要动态代理？我来简单解释一下吧！</p>
<p>我们知道代理模式就是： 我们给某一个对象提供一个代理对象，并由代理对象来代替真实对象做一些事情。你可以把代理对象理解为一个幕后的工具人。 举个例子：我们真实对象调用方法的时候，我们可以通过代理对象去做一些事情比如安全校验、日志打印等等。但是，这个过程是完全对真实对象屏蔽的。</p>
<p>讲完了代理模式，再来说动态代理在 RPC 框架中的作用。</p>
<p>前面第一节的时候，我们就已经提到 ：<strong>RPC 的主要目的就是让我们调用远程方法像调用本地方法一样简单，我们不需要关心远程方法调用的细节比如网络传输。</strong></p>
<p><strong>怎样才能屏蔽远程方法调用的底层细节呢？</strong></p>
<p>答案就是<strong>动态代理</strong>。简单来说，当你调用远程方法的时候，实际会通过代理对象来传输网络请求，不然的话，怎么可能直接就调用到远程方法。</p>
<p>相关文章： <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/proxy.html">代理模式详解：静态代理+JDK&#x2F;CGLIB 动态代理实战</a></p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>为什么需要负载均衡？</p>
<p>举个例子：我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。</p>
<h4 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h4><p>我们还需要设计一个私有的 RPC 协议，这个协议是客户端（服务消费方）和服务端（服务提供方）交流的基础。</p>
<p>简单来说：<strong>通过设计协议，我们定义需要传输哪些类型的数据， 并且还会规定每一种类型的数据应该占多少字节。这样我们在接收到二进制数据之后，就可以正确的解析出我们需要的数据。这有一点像密文传输的感觉。</strong></p>
<p>通常一些标准的 RPC 协议包含下面这些内容：</p>
<ul>
<li><strong>魔数：</strong> 通常是 4 个字节。这个魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。 </li>
<li><strong>序列化器编号：</strong>标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kryo 等序列化方式。 </li>
<li><strong>消息体长度：</strong> 运行时计算出来。 </li>
<li>……</li>
</ul>
<h3 id="实现一个最基本的-RPC-框架需要哪些技术"><a href="#实现一个最基本的-RPC-框架需要哪些技术" class="headerlink" title="实现一个最基本的 RPC 框架需要哪些技术"></a>实现一个最基本的 RPC 框架需要哪些技术</h3><p>按照我实现的这一款基于 Netty+kryo+Zookeeper 实现的 RPC 框架来说的话，你需要下面这些技术支撑：</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><ol>
<li>动态代理机制；</li>
<li>序列化机制以及各种序列化框架的对比，比如 hession2、kryo、protostuff；</li>
<li>线程池的使用；</li>
<li><code>CompletableFuture </code>的使用；</li>
<li>……</li>
</ol>
<h4 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h4><ol>
<li>使用 Netty 进行网络传输；</li>
<li><code>ByteBuf </code>介绍；</li>
<li>Netty 粘包拆包；</li>
<li>Netty 长连接和心跳机制；</li>
<li>……</li>
</ol>
<h4 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h4><ol>
<li>基本概念；</li>
<li>数据结构；</li>
<li>如何使用 Netflix 公司开源的 Zookeeper 客户端框架 Curator 进行增删改查；</li>
<li>……</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>实现一个最基本的 RPC 框架应该至少包括下面几部分:</p>
<ol>
<li><strong>注册中心：</strong>注册中心负责服务地址的注册与查找，相当于目录服务。</li>
<li><strong>网络传输：</strong>既然我们要调用远程的方法，就要发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务提供端。</li>
<li><strong>序列化和反序列化：</strong>要在网络传输数据就要涉及到序列化。</li>
<li><strong>动态代理：</strong>屏蔽远程方法调用的底层细节。</li>
<li><strong>负载均衡：</strong> 避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题。</li>
<li><strong>传输协议：</strong>这个协议是客户端（服务消费方）和服务端（服务提供方）交流的基础。</li>
</ol>
<p>更完善的一点的 RPC 框架可能还有监控模块（拓展：你可以研究一下 Dubbo 的监控模块的设计）。</p>
<h2 id="序列化介绍以及序列化协议选择"><a href="#序列化介绍以及序列化协议选择" class="headerlink" title="序列化介绍以及序列化协议选择"></a>序列化介绍以及序列化协议选择</h2><h3 id="什么是序列化和反序列化"><a href="#什么是序列化和反序列化" class="headerlink" title="什么是序列化和反序列化"></a>什么是序列化和反序列化</h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>
<p>简单来说：</p>
<ul>
<li><strong>序列化：</strong>将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化：</strong>将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p>
<p>下面是序列化和反序列化常见应用场景：</p>
<ul>
<li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>
<li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>
<li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li>
<li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li>
</ul>
<p>维基百科是这样介绍序列化的：</p>
<blockquote>
<p><strong>序列化</strong>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p>
</blockquote>
<p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="序列化和反序列化"></p>
<p><strong>序列化协议对应于 TCP&#x2F;IP 4 层模型的哪一层？</strong></p>
<p>我们知道网络通信的双方必须要采用和遵守相同的协议。TCP&#x2F;IP 四层模型是下面这样的，序列化协议属于哪一层呢？</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/64adec3d-78ee-488f-92ad-ad3013006985.png" alt="64adec3d-78ee-488f-92ad-ad3013006985"></p>
<p>如上图所示，OSI 七层协议模型中，<strong>表示层</strong>做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？</p>
<p>因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP&#x2F;IP 四层模型中的应用层，所以序列化协议属于 TCP&#x2F;IP 协议<strong>应用层</strong>的一部分。</p>
<h3 id="常见的序列化协议有哪些"><a href="#常见的序列化协议有哪些" class="headerlink" title="常见的序列化协议有哪些"></a>常见的序列化协议有哪些</h3><p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</p>
<p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p>
<h4 id="JDK自带的序列化方式"><a href="#JDK自带的序列化方式" class="headerlink" title="JDK自带的序列化方式"></a>JDK自带的序列化方式</h4><p>JDK 自带的序列化，只需实现 <code>java.io.Serializable</code>接口即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1905122041950251207L</span>;</span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line">    <span class="keyword">private</span> RpcMessageTypeEnum rpcMessageTypeEnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>serialVersionUID 有什么作用？</strong></p>
<p>序列化号 <code>serialVersionUID </code>属于版本控制的作用。反序列化时，会检查 <code>serialVersionUID </code>是否和当前类的 <code>serialVersionUID </code>一致。如果 <code>serialVersionUID </code>不一致则会抛出 <code>InvalidClassException </code>异常。强烈推荐每个序列化类都手动指定其 <code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的 <code>serialVersionUID</code>。</p>
<p><strong>serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？</strong></p>
<p><code>static </code>修饰的变量是静态变量，位于方法区，本身是不会被序列化的。 <code>static </code>变量是属于类的而不是对象。你反序列之后，<code>static </code>变量的值就像是默认赋予给了对象一样，看着就像是 <code>static </code>变量被序列化，实际只是<strong>假象</strong>罢了。</p>
<p><strong>如果有些字段不想进行序列化怎么办？</strong></p>
<p>对于不想进行序列化的变量，可以使用 <code>transient </code>关键字修饰。</p>
<p><code>transient </code>关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient </code>修饰的变量值不会被持久化和恢复。</p>
<p>关于 <code>transient </code>还有几点注意：</p>
<ul>
<li><code>transient</code>只能修饰变量，不能修饰类和方法。</li>
<li><code>transient</code>修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li>
<li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li>
</ul>
<p><strong>为什么不推荐使用 JDK 自带的序列化？</strong></p>
<p>我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：</p>
<ul>
<li><strong>不支持跨语言调用:</strong> 如果调用的是其他语言开发的服务的时候就不支持了。</li>
<li><strong>性能差：</strong>相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
<li><strong>存在安全问题：</strong>序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。相关阅读：<a target="_blank" rel="noopener" href="https://cryin.github.io/blog/secure-development-java-deserialization-vulnerability/">应用安全:JAVA反序列化漏洞之殇 - Cryin</a> 、<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/37562657/answer/1916596031">Java反序列化安全漏洞怎么回事? - Monica</a>。</li>
</ul>
<h4 id="Kyro"><a href="#Kyro" class="headerlink" title="Kyro"></a>Kyro</h4><p>Kryo 是一个高性能的序列化&#x2F;反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p>
<p>另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。</p>
<p>序列化和反序列化相关的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KryoSerializer</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        kryo.register(RpcResponse.class);</span><br><span class="line">        kryo.register(RpcRequest.class);</span><br><span class="line">        <span class="keyword">return</span> kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">             <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(byteArrayOutputStream)) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// Object-&gt;byte:将对象序列化为byte数组</span></span><br><span class="line">            kryo.writeObject(output, obj);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> output.toBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Serialization failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">             <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(byteArrayInputStream)) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// byte-&gt;Object:从byte数组中反序列化出对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> kryo.readObject(input, clazz);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> clazz.cast(o);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Deserialization failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Github 地址：<a target="_blank" rel="noopener" href="https://github.com/EsotericSoftware/kryo">https://github.com/EsotericSoftware/kryo</a></p>
<h4 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h4><p>Protobuf 出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。</p>
<blockquote>
<p>Protobuf 包含序列化格式的定义、各种语言的库以及一个 IDL 编译器。正常情况下你需要定义 proto 文件，然后使用 IDL 编译器编译成你需要的语言</p>
</blockquote>
<p>一个简单的 proto 文件如下：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// protobuf的版本</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">// SearchRequest会被编译成不同的编程语言的相应对象，比如Java中的class、Go中的struct</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">//string类型字段</span></span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// int 类型字段</span></span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Github 地址：<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf">https://github.com/protocolbuffers/protobuf</a></p>
<h4 id="ProtoStuff"><a href="#ProtoStuff" class="headerlink" title="ProtoStuff"></a>ProtoStuff</h4><p>由于 Protobuf 的易用性，它的哥哥 Protostuff 诞生了。</p>
<p>protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。</p>
<p>Github 地址：<a target="_blank" rel="noopener" href="https://github.com/protostuff/protostuff">https://github.com/protostuff/protostuff</a></p>
<h4 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h4><p>Hessian 是一个轻量级的，自定义描述的二进制 RPC 协议。Hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/Hessian.png" alt="Hessian"></p>
<p>Dubbo2.x 默认启用的序列化方式是 Hessian2 ,但是，Dubbo 对 Hessian2 进行了修改，不过大体结构还是差不多。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果你的应用是专门针对 Java 语言的话可以考虑使用，并且 Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。(文章地址：<a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/">https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/</a>)</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/ae56c10e-532e-49b2-8874-c316ad1b6880.png" alt="ae56c10e-532e-49b2-8874-c316ad1b6880"></p>
<p>像 Protobuf、 ProtoStuff、hessian 这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。</p>
<p>除了上面介绍到的序列化方式的话，还有像 Thrift，Avro 这些。</p>
<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul>
<li>美团技术团队-序列化和反序列化：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html">https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html</a></li>
<li>在 Dubbo 中使用高效的 Java 序列化（Kryo 和 FST）: <a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/v3.0/references/serializations/serialization/">https://dubbo.apache.org/zh/docs/v3.0/references/serializations/serialization/</a></li>
</ul>
<h2 id="Socket网络通信实战"><a href="#Socket网络通信实战" class="headerlink" title="Socket网络通信实战"></a>Socket网络通信实战</h2><h3 id="什么是Socket-套接字"><a href="#什么是Socket-套接字" class="headerlink" title="什么是Socket(套接字)"></a>什么是Socket(套接字)</h3><p>Socket 是一个抽象概念，应用程序可以通过它发送或接收数据。在使用 Socket 进行网络通信的时候，通过 Socket 就可以让我们的数据在网络中传输。操作套接字的时候，和我们读写文件很像。套接字是 IP 地址与端口的组合，<strong>套接字 Socket&#x3D;（IP 地址：端口号）</strong>。</p>
<p>要通过互联网进行通信，至少需要一对套接字：</p>
<ol>
<li>运行于服务器端的 Server Socket。</li>
<li>运行于客户机端的 Client Socket</li>
</ol>
<p>在 Java 开发中使用 Socket 时会常用到两个类，都在 <code>java.net</code> 包中：</p>
<ol>
<li><code>Socket</code>: 一般用于客户端</li>
<li><code>ServerSocket </code>:用于服务端</li>
</ol>
<h2 id="Socket网路通信过程"><a href="#Socket网路通信过程" class="headerlink" title="Socket网路通信过程"></a>Socket网路通信过程</h2><p>Socket 网络通信过程如下图所示：</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/aacf635e-4ed6-4ba5-9346-d45500b48098.png" alt="aacf635e-4ed6-4ba5-9346-d45500b48098"></p>
<p><strong>Socket 网络通信过程简单来说分为下面 4 步：</strong></p>
<ol>
<li>建立服务端并且监听客户端请求</li>
<li>客户端请求，服务端和客户端建立连接</li>
<li>两端之间可以传递数据</li>
<li>关闭资源</li>
</ol>
<p>对应到服务端和客户端的话，是下面这样的。</p>
<p><strong>服务器端：</strong></p>
<ol>
<li>创建 <code>ServerSocket</code> 对象并且绑定地址（ip）和端口号(port)：<code>server.bind(new InetSocketAddress(host, port))</code></li>
<li>通过 <code>accept()</code>方法监听客户端请求</li>
<li>连接建立后，通过输入流读取客户端发送的请求信息</li>
<li>通过输出流向客户端发送响应信息</li>
<li>关闭相关资源</li>
</ol>
<p><strong>客户端：</strong></p>
<ol>
<li>创建<code>Socket</code> 对象并且连接指定的服务器的地址（ip）和端口号(port)：<code>socket.connect(inetSocketAddress)</code></li>
<li>连接建立后，通过输出流向服务器端发送请求信息</li>
<li>通过输入流获取服务器响应的信息</li>
<li>关闭相关资源</li>
</ol>
<h3 id="Socket网络通信实战-1"><a href="#Socket网络通信实战-1" class="headerlink" title="Socket网络通信实战"></a>Socket网络通信实战</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建 ServerSocket 对象并且绑定一个端口</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);) &#123;</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="comment">//2.通过 accept()方法监听客户端请求</span></span><br><span class="line">            <span class="keyword">while</span> ((socket = server.accept()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;client connected&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(socket.getInputStream());</span><br><span class="line">                     <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(socket.getOutputStream())) &#123;</span><br><span class="line">                   <span class="comment">//3.通过输入流读取客户端发送的请求信息</span></span><br><span class="line">                    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) objectInputStream.readObject();</span><br><span class="line">                    logger.info(<span class="string">&quot;server receive message:&quot;</span> + message.getContent());</span><br><span class="line">                    message.setContent(<span class="string">&quot;new content&quot;</span>);</span><br><span class="line">                    <span class="comment">//4.通过输出流向客户端发送响应信息</span></span><br><span class="line">                    objectOutputStream.writeObject(message);</span><br><span class="line">                    objectOutputStream.flush();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;occur exception:&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;occur IOException:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HelloServer</span> <span class="variable">helloServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServer</span>();</span><br><span class="line">        helloServer.start(<span class="number">6666</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ServerSocket</code> 的 <code>accept()</code> 方法是阻塞方法，也就是说 <code>ServerSocket</code> 在调用 <code>accept()</code>等待客户端的连接请求时会阻塞，直到收到客户端发送的连接请求才会继续往下执行代码。</p>
<p>很明显，上面演示的代码片段有一个很严重的问题：<strong>只能同时处理一个客户端的连接，如果需要管理多个客户端的话，就需要为我们请求的客户端单独创建一个线程。</strong> 如下图所示：</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/e82fa468-e17d-445a-8668-01b11e573a8a.png" alt="e82fa468-e17d-445a-8668-01b11e573a8a"></p>
<p>对应的 Java 代码可能是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">   <span class="comment">// 创建 socket 连接</span></span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>但是，这样会导致一个很严重的问题：<strong>资源浪费</strong>。</p>
<p>我们知道线程是很宝贵的资源，如果我们为每一次连接都用一个线程处理的话，就会导致线程越来越多，最后达到了极限之后，就无法再创建线程处理请求了。处理的不好的话，甚至可能直接就宕机掉了。</p>
<p>很多人就会问了：那有没有改进的方法呢？</p>
<p>当然有！ 比较简单并且实际的改进方法就是使用<strong>线程池</strong>。线程池还可以让线程的创建和回收成本相对较低，并且我们可以指定线程池的可创建线程的最大数量，这样就不会导致线程创建过多，机器资源被不合理消耗。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> Executors.defaultThreadFactory();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">100</span>, <span class="number">1</span>, TimeUnit.MINUTES, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">100</span>), threadFactory);</span><br><span class="line">threadPool.execute(() -&gt; &#123;</span><br><span class="line">     <span class="comment">// 创建 socket 连接</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>但是，即使你再怎么优化和改变。也改变不了它的底层仍然是同步阻塞的 BIO 模型的事实，因此无法从根本上解决问题。</strong></p>
<p><strong>为了解决上述的问题，Java 1.4 中引入了 NIO ，一种同步非阻塞的 I&#x2F;O 模型。</strong> 由于使用同步非阻塞的 I&#x2F;O 模型 <strong>NIO</strong> 来进行网络编程真的太麻烦了。你可以使用基于 NIO 的网络编程框架 Netty ，它将是你最好的选择（前面的章节提到过，后面的章节会详细讲解如何使用 Netty 进行网络编程）！</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">send</span><span class="params">(Message message, String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 创建Socket对象并且指定服务器的地址和端口号</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(host, port)) &#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">//2.通过输出流向服务器端发送请求信息</span></span><br><span class="line">            objectOutputStream.writeObject(message);</span><br><span class="line">            <span class="comment">//3.通过输入流获取服务器响应的信息</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(socket.getInputStream());</span><br><span class="line">            <span class="keyword">return</span> objectInputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;occur exception:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HelloClient</span> <span class="variable">helloClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloClient</span>();</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) helloClient.send(<span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;content from client&quot;</span>), <span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;client receive message:&quot;</span> + message.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发送的消息实体类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Message</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>首先运行服务端，然后再运行客户端，控制台输出如下：</strong></p>
<p>服务端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[main] INFO github.javaguide.socket.HelloServer - client connected</span><br><span class="line">[main] INFO github.javaguide.socket.HelloServer - server receive message:content from client</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client receive message:new content</span><br></pre></td></tr></table></figure>

<h2 id="Netty从入门到网络通信实战"><a href="#Netty从入门到网络通信实战" class="headerlink" title="Netty从入门到网络通信实战"></a>Netty从入门到网络通信实战</h2><h3 id="Netty介绍"><a href="#Netty介绍" class="headerlink" title="Netty介绍"></a>Netty介绍</h3><ol>
<li><strong>Netty 是一个基于 NIO 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。</strong></li>
<li>它极大地简化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。</li>
<li>支持多种协议如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。</li>
</ol>
<p>用官方的总结就是：<strong>Netty 成功地找到了一种在不妥协可维护性和性能的情况下实现易于开发，性能，稳定性和灵活性的方法。</strong></p>
<h3 id="Netty特点"><a href="#Netty特点" class="headerlink" title="Netty特点"></a>Netty特点</h3><p>根据官网的描述，我们可以总结出下面一些特点：</p>
<ul>
<li>统一的 API，支持多种传输类型，阻塞和非阻塞的。</li>
<li>简单而强大的线程模型。</li>
<li>自带编解码器解决 TCP 粘包&#x2F;拆包问题。</li>
<li>自带各种协议栈。</li>
<li>真正的无连接数据包套接字支持。</li>
<li>比直接使用 Java 核心 API 有更高的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制。</li>
<li>安全性不错，有完整的 SSL&#x2F;TLS 以及 StartTLS 支持。</li>
<li>社区活跃</li>
<li>成熟稳定，经历了大型项目的使用和考验，而且很多开源项目都使用到了 Netty 比如我们经常接触的 Dubbo、RocketMQ 等等。</li>
<li>……</li>
</ul>
<h3 id="Netty能做什么"><a href="#Netty能做什么" class="headerlink" title="Netty能做什么"></a>Netty能做什么</h3><p>简单说一下，理论上 NIO 可以做的事情 ，使用 Netty 都可以做并且更好。Netty 主要用来做<strong>网络通信</strong> :</p>
<ul>
<li><strong>作为 RPC 框架的网络通信工具 ：</strong> 我们在分布式系统中，不同服务节点之间经常需要相互调用，这个时候就需要 RPC 框架了。不同服务节点的通信是如何做的呢？可以使用 Netty 来做。比如我调用另外一个节点的方法的话，至少是要让对方知道我调用的是哪个类中的哪个方法以及相关参数吧！</li>
<li><strong>实现一个自己的 HTTP 服务器 ：</strong>通过 Netty 我们可以自己实现一个简单的 HTTP 服务器，这个大家应该不陌生。说到 HTTP 服务器的话，作为 Java 后端开发，我们一般使用 Tomcat 比较多。一个最基本的 HTTP 服务器可要以处理常见的 HTTP Method 的请求，比如 POST 请求、GET 请求等等。</li>
<li><strong>实现一个即时通讯系统 ：</strong> 使用 Netty 我们可以实现一个可以聊天类似微信的即时通讯系统，这方面的开源项目还蛮多的，可以自行去 Github 找一找。</li>
<li><strong>消息推送系统 ：</strong>市面上有很多消息推送系统都是基于 Netty 来做的。</li>
<li>……</li>
</ul>
<h3 id="哪些开源项目用到了Netty"><a href="#哪些开源项目用到了Netty" class="headerlink" title="哪些开源项目用到了Netty"></a>哪些开源项目用到了Netty</h3><p>我们平常经常接触的 Dubbo、RocketMQ、Elasticsearch、gRPC 等等都用到了 Netty。</p>
<p>可以说大量的开源项目都用到了 Netty，所以掌握 Netty 有助于你更好的使用这些开源项目并且让你有能力对其进行二次开发。</p>
<p>实际上还有很多很多优秀的项目用到了 Netty,Netty 官方也做了统计，统计结果在这里：<a target="_blank" rel="noopener" href="https://netty.io/wiki/related-projects.html">https://netty.io/wiki/related-projects.html</a>。</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/8308a46f-642e-477d-a289-791ffe08b6fd.png" alt="8308a46f-642e-477d-a289-791ffe08b6fd"></p>
<h3 id="Netty-使用-Kryo-序列化传输对象实战"><a href="#Netty-使用-Kryo-序列化传输对象实战" class="headerlink" title="Netty 使用 Kryo 序列化传输对象实战"></a>Netty 使用 Kryo 序列化传输对象实战</h3><blockquote>
<p><strong>注意：</strong>Kryo不支持没有无参构造函数的对象进行反序列化，因此如果某个对象希望使用Kryo来进行序列化操作的话，需要有相应的无参构造函数才可以。</p>
</blockquote>
<h4 id="传输实体类"><a href="#传输实体类" class="headerlink" title="传输实体类"></a>传输实体类</h4><p><strong>我们首先定义两个对象，这两个对象是客户端与服务端进行交互的实体类。</strong> 客户端将 <code>RpcRequest</code>类型的对象发送到服务端，服务端进行相应的处理之后将得到结果 <code>RpcResponse</code> 对象返回给客户端。</p>
<h5 id="客户端请求"><a href="#客户端请求" class="headerlink" title="客户端请求"></a>客户端请求</h5><p><code>RpcRequest.java</code> :客户端请求实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务器端响应"><a href="#服务器端响应" class="headerlink" title="服务器端响应"></a>服务器端响应</h5><p><code>RpcResponse.java</code> ：服务端响应实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcResponse</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><h5 id="初始化客户端"><a href="#初始化客户端" class="headerlink" title="初始化客户端"></a>初始化客户端</h5><p>客户端中主要有一个用于向服务端发送消息的 <code>sendMessage()</code>方法，通过这个方法你可以将消息也就是<code>RpcRequest</code> 对象发送到服务端，并且你可以同步获取到服务端返回的结果也就是<code>RpcResponse</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(NettyClient.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Bootstrap b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NettyClient</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.host = host;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化相关资源比如 EventLoopGroup, Bootstrap</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">eventLoopGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        b = <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        <span class="type">KryoSerializer</span> <span class="variable">kryoSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KryoSerializer</span>();</span><br><span class="line">        b.group(eventLoopGroup)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                <span class="comment">// 连接的超时时间，超过这个时间还是建立不上的话则代表连接失败</span></span><br><span class="line">                <span class="comment">// 如果 15 秒之内没有发送数据给服务端的话，就发送一次心跳请求</span></span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         自定义序列化编解码器</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="comment">// RpcResponse -&gt; ByteBuf</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyKryoDecoder</span>(kryoSerializer, RpcResponse.class));</span><br><span class="line">                        <span class="comment">// ByteBuf -&gt; RpcRequest</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyKryoEncoder</span>(kryoSerializer, RpcRequest.class));</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息到服务端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rpcRequest 消息体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务端返回的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RpcResponse <span class="title function_">sendMessage</span><span class="params">(RpcRequest rpcRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.connect(host, port).sync();</span><br><span class="line">            logger.info(<span class="string">&quot;client connect  &#123;&#125;&quot;</span>, host + <span class="string">&quot;:&quot;</span> + port);</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">futureChannel</span> <span class="operator">=</span> f.channel();</span><br><span class="line">            logger.info(<span class="string">&quot;send message&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (futureChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">                futureChannel.writeAndFlush(rpcRequest).addListener(future -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                        logger.info(<span class="string">&quot;client send message: [&#123;&#125;]&quot;</span>, rpcRequest.toString());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        logger.error(<span class="string">&quot;Send failed:&quot;</span>, future.cause());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">               <span class="comment">//阻塞等待 ，直到Channel关闭</span></span><br><span class="line">                futureChannel.closeFuture().sync();</span><br><span class="line">               <span class="comment">// 将服务端返回的数据也就是RpcResponse对象取出</span></span><br><span class="line">                AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="string">&quot;rpcResponse&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> futureChannel.attr(key).get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;occur exception when connect server:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sendMessage()</code>方法分析：</p>
<ol>
<li>首先初始化了一个 <code>Bootstrap</code></li>
<li>通过 <code>Bootstrap</code> 对象连接服务端</li>
<li>通过 <code>Channel</code> 向服务端发送消息<code>RpcRequest</code></li>
<li>发送成功后，阻塞等待 ，直到<code>Channel</code>关闭</li>
<li>拿到服务端返回的结果 <code>RpcResponse</code></li>
</ol>
<h5 id="自定义-ChannelHandler-处理服务端消息"><a href="#自定义-ChannelHandler-处理服务端消息" class="headerlink" title="自定义 ChannelHandler 处理服务端消息"></a>自定义 ChannelHandler 处理服务端消息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(NettyClientHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> (RpcResponse) msg;</span><br><span class="line">            logger.info(<span class="string">&quot;client receive msg: [&#123;&#125;]&quot;</span>, rpcResponse.toString());</span><br><span class="line">            <span class="comment">// 声明一个 AttributeKey 对象</span></span><br><span class="line">            AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="string">&quot;rpcResponse&quot;</span>);</span><br><span class="line">            <span class="comment">// 将服务端的返回结果保存到 AttributeMap 上，AttributeMap 可以看作是一个Channel的共享数据源</span></span><br><span class="line">            <span class="comment">// AttributeMap的key是AttributeKey，value是Attribute</span></span><br><span class="line">            ctx.channel().attr(key).set(rpcResponse);</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;client caught exception&quot;</span>, cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NettyClientHandler</code>用于读取服务端发送过来的 <code>RpcResponse</code> 消息对象，并将 <code>RpcResponse</code> 消息对象保存到 <code>AttributeMap</code> 上，<code>AttributeMap</code> 可以看作是一个<code>Channel</code>的共享数据源。</p>
<p>这样的话，我们就能通过 channel 和 key 将数据读取出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="string">&quot;rpcResponse&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> futureChannel.attr(key).get();</span><br></pre></td></tr></table></figure>

<p>额外提一下 <code>AttributeMap</code> ,<code>AttributeMap</code> 是一个接口，但是类似于 <code>Map</code> 数据结构 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AttributeMap</span> &#123;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; Attribute&lt;T&gt; <span class="title function_">attr</span><span class="params">(AttributeKey&lt;T&gt; key)</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="type">boolean</span> <span class="title function_">hasAttr</span><span class="params">(AttributeKey&lt;T&gt; key)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Channel</code> 实现了 <code>AttributeMap</code> 接口，这样也就表明它存在了<code>AttributeMap</code> 相关的属性。 每个 <code>Channel</code>上的<code>AttributeMap</code>属于共享数据。<code>AttributeMap</code> 的结构，和<code>Map</code>很像，我们可以把 <code>key</code> 看作是<code>AttributeKey</code>，<code>value</code> 看作是<code>Attribute</code>，我们可以根据 <code>AttributeKey</code>找到对应的<code>Attribute</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span> <span class="keyword">extends</span> <span class="title class_">AttributeMap</span>, ChannelOutboundInvoker, Comparable&lt;Channel&gt; &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><h5 id="初始化服务端"><a href="#初始化服务端" class="headerlink" title="初始化服务端"></a>初始化服务端</h5><p><code>NettyServer</code> <strong>主要作用就是开启了一个服务端用于接受客户端的请求并处理。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(NettyServer.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NettyServer</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">KryoSerializer</span> <span class="variable">kryoSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KryoSerializer</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span></span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">// 是否开启 TCP 底层心跳机制</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">//表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyKryoDecoder</span>(kryoSerializer, RpcRequest.class));</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyKryoEncoder</span>(kryoSerializer, RpcResponse.class));</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定端口，同步等待绑定成功</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind(port).sync();</span><br><span class="line">            <span class="comment">// 等待服务端监听端口关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;occur exception when start server:&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自定义-ChannelHandler-处理客户端消息"><a href="#自定义-ChannelHandler-处理客户端消息" class="headerlink" title="自定义 ChannelHandler 处理客户端消息"></a>自定义 ChannelHandler 处理客户端消息</h5><p><code>NettyServerHandler</code> <strong>用于接收客户端发送过来的消息并返回结果给客户端。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(NettyServerHandler.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> (RpcRequest) msg;</span><br><span class="line">            logger.info(<span class="string">&quot;server receive msg: [&#123;&#125;] ,times:[&#123;&#125;]&quot;</span>, rpcRequest, atomicInteger.getAndIncrement());</span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">messageFromServer</span> <span class="operator">=</span> RpcResponse.builder().message(<span class="string">&quot;message from server&quot;</span>).build();</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> ctx.writeAndFlush(messageFromServer);</span><br><span class="line">            f.addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;server catch exception&quot;</span>,cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><h4 id="自定义编码器"><a href="#自定义编码器" class="headerlink" title="自定义编码器"></a>自定义编码器</h4><p><code>NettyKryoEncoder</code> 是我们自定义的编码器。它负责处理”出站”消息，将消息格式转换为字节数组然后写入到字节数据的容器 <code>ByteBuf</code> 对象中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义编码器。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 网络传输需要通过字节流来实现，ByteBuf 可以看作是 Netty 提供的字节数据的容器，使用它会让我们更加方便地处理字节数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyKryoEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToByteEncoder</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Serializer serializer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; genericClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将对象转换为字节码然后写入到 ByteBuf 对象中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Object o, ByteBuf byteBuf)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (genericClass.isInstance(o)) &#123;</span><br><span class="line">            <span class="comment">// 1. 将对象转换为byte</span></span><br><span class="line">            <span class="type">byte</span>[] body = serializer.serialize(o);</span><br><span class="line">            <span class="comment">// 2. 读取消息的长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">dataLength</span> <span class="operator">=</span> body.length;</span><br><span class="line">            <span class="comment">// 3.写入消息对应的字节数组长度,writerIndex 加 4</span></span><br><span class="line">            byteBuf.writeInt(dataLength);</span><br><span class="line">            <span class="comment">//4.将字节数组写入 ByteBuf 对象中</span></span><br><span class="line">            byteBuf.writeBytes(body);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义解码器"><a href="#自定义解码器" class="headerlink" title="自定义解码器"></a>自定义解码器</h4><p><code>NettyKryoDecoder</code>是我们自定义的解码器。它负责处理”入站”消息，它会从 <code>ByteBuf</code>中读取到业务对象对应的字节序列，然后再将字节序列转换为我们的业务对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义解码器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyKryoDecoder</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageDecoder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Serializer serializer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; genericClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Netty传输的消息长度也就是对象序列化后对应的字节数组的大小，存储在 ByteBuf 头部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BODY_LENGTH</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码 ByteBuf 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 解码器关联的 ChannelHandlerContext 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in  &quot;入站&quot;数据，也就是 ByteBuf 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out 解码之后的数据对象需要添加到 out 对象里面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.byteBuf中写入的消息长度所占的字节数已经是4了，所以 byteBuf 的可读字节必须大于 4，</span></span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &gt;= BODY_LENGTH) &#123;</span><br><span class="line">            <span class="comment">//2.标记当前readIndex的位置，以便后面重置readIndex 的时候使用</span></span><br><span class="line">            in.markReaderIndex();</span><br><span class="line">            <span class="comment">//3.读取消息的长度</span></span><br><span class="line">            <span class="comment">//注意：消息长度是encode的时候我们自己写入的，参见 NettyKryoEncoder 的encode方法</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">dataLength</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">            <span class="comment">//4.遇到不合理的情况直接 return</span></span><br><span class="line">            <span class="keyword">if</span> (dataLength &lt; <span class="number">0</span> || in.readableBytes() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;data length or byteBuf readableBytes is not valid&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5.如果可读字节数小于消息长度的话，说明是不完整的消息，重置readIndex</span></span><br><span class="line">            <span class="keyword">if</span> (in.readableBytes() &lt; dataLength) &#123;</span><br><span class="line">                in.resetReaderIndex();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.走到这里说明没什么问题了，可以序列化了</span></span><br><span class="line">            <span class="type">byte</span>[] body = <span class="keyword">new</span> <span class="title class_">byte</span>[dataLength];</span><br><span class="line">            in.readBytes(body);</span><br><span class="line">            <span class="comment">// 将bytes数组转换为我们需要的对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> serializer.deserialize(body, genericClass);</span><br><span class="line">            out.add(obj);</span><br><span class="line">            log.info(<span class="string">&quot;successful decode ByteBuf to Object&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义序列化接口"><a href="#自定义序列化接口" class="headerlink" title="自定义序列化接口"></a>自定义序列化接口</h4><p><code>Serializer</code> 接口主要有两个方法一个用于序列化，一个用户反序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 要序列化的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">byte</span>[] serialize(Object obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 序列化后的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 反序列化的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;T&gt; clazz)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现序列化接口"><a href="#实现序列化接口" class="headerlink" title="实现序列化接口"></a>实现序列化接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KryoSerializer</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于 Kryo 不是线程安全的。每个线程都应该有自己的 Kryo，Input 和 Output 实例。</span></span><br><span class="line"><span class="comment">     * 所以，使用 ThreadLocal 存放 Kryo 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        kryo.register(RpcResponse.class);</span><br><span class="line">        kryo.register(RpcRequest.class);</span><br><span class="line">        kryo.setReferences(<span class="literal">true</span>);<span class="comment">//默认值为true,是否关闭注册行为,关闭之后可能存在序列化问题，一般推荐设置为 true</span></span><br><span class="line">        kryo.setRegistrationRequired(<span class="literal">false</span>);<span class="comment">//默认值为false,是否关闭循环引用，可以提高性能，但是一般不推荐设置为 true</span></span><br><span class="line">        <span class="keyword">return</span> kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">             <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(byteArrayOutputStream)) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// Object-&gt;byte:将对象序列化为byte数组</span></span><br><span class="line">            kryo.writeObject(output, obj);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> output.toBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;序列化失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">             <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(byteArrayInputStream)) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// byte-&gt;Object:从byte数组中反序列化出对对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> kryo.readObject(input, clazz);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> clazz.cast(o);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;反序列化失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义序列化异常类 <code>SerializeException</code> 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SerializeException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h3><p><strong>启动服务端：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">NettyServer</span>(<span class="number">8889</span>).run();</span><br></pre></td></tr></table></figure>

<p><strong>启动客户端并发送 4 次消息给服务端：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> RpcRequest.builder()</span><br><span class="line">  .interfaceName(<span class="string">&quot;interface&quot;</span>)</span><br><span class="line">  .methodName(<span class="string">&quot;hello&quot;</span>).build();</span><br><span class="line"><span class="type">NettyClient</span> <span class="variable">nettyClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyClient</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8889</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  nettyClient.sendMessage(rpcRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> nettyClient.sendMessage(rpcRequest);</span><br><span class="line">System.out.println(rpcResponse.toString());</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/5823b0ff-e6f2-402d-83e7-f7d8904809f3.png" alt="5823b0ff-e6f2-402d-83e7-f7d8904809f3"></p>
<p><strong>服务端控制台输出：</strong></p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/e2d76c20-4f39-4aff-8723-f0f3fcdca27d.png" alt="e2d76c20-4f39-4aff-8723-f0f3fcdca27d"></p>
<h2 id="静态代理-JDK-x2F-CGLIB-动态代理实战"><a href="#静态代理-JDK-x2F-CGLIB-动态代理实战" class="headerlink" title="静态代理+JDK&#x2F;CGLIB 动态代理实战"></a>静态代理+JDK&#x2F;CGLIB 动态代理实战</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式是一种比较好的理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>
<p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p>
<p>举个例子：你找了小红来帮你问话，小红就可以看作是代理你的代理对象，代理的行为（方法）是问话。</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/1597030048717-a9d59ae7-2ae3-4537-956b-704129a4826e.png" alt="1597030048717-a9d59ae7-2ae3-4537-956b-704129a4826e"></p>
<p>代理模式有静态代理和动态代理两种实现方式，我们先来看一下静态代理模式的实现。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
<p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， 静<strong>态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p>
<p>静态代理实现步骤:</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<p>下面通过代码展示</p>
<p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.创建代理类并同样实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsProxy</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsProxy</span><span class="params">(SmsService smsService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method send()&quot;</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method send()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>();</span><br><span class="line">        <span class="type">SmsProxy</span> <span class="variable">smsProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsProxy</span>(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send()</span><br><span class="line">send message:java</span><br><span class="line">after method send()</span><br></pre></td></tr></table></figure>

<p>可以输出结果看出，我们已经增强了 <code>SmsServiceImpl</code> 的<code>send()</code>方法。</p>
<h3 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h3><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类(CGLIB 动态代理机制)。</p>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p>
<p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。</p>
<p><strong>动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p>
<p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p>
<h4 id="JDK-动态代理机制"><a href="#JDK-动态代理机制" class="headerlink" title="JDK 动态代理机制"></a>JDK 动态代理机制</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>
<p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法一共有 3 个参数：</p>
<ol>
<li>**loader :**类加载器，用于加载代理对象。</li>
<li><strong>interfaces :</strong> 被代理类实现的一些接口；</li>
<li><strong>h :</strong> 实现了 <code>InvocationHandler</code> 接口的对象；</li>
</ol>
<p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法有下面三个参数：</p>
<ol>
<li>**proxy :**动态生成的代理类</li>
<li><strong>method :</strong> 与代理类对象调用的方法相对应</li>
<li><strong>args :</strong> 当前 method 方法的参数</li>
</ol>
<p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>
<h5 id="JDK-动态代理类使用步骤"><a href="#JDK-动态代理类使用步骤" class="headerlink" title="JDK 动态代理类使用步骤"></a>JDK 动态代理类使用步骤</h5><ol>
<li>定义一个接口及其实现类；</li>
<li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li>
</ol>
<h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.定义一个 JDK 动态代理类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p>
<p><strong>4.获取代理对象的工厂类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DebugInvocationHandler</span>(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance()</code>方法获取某个类的代理对象</p>
<p><strong>5.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>());</span><br><span class="line">smsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure>

<h4 id="CGLIB动态代理机制"><a href="#CGLIB动态代理机制" class="headerlink" title="CGLIB动态代理机制"></a>CGLIB动态代理机制</h4><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p>
<p><strong>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">CGLIB</a>(Code Generation Library)是一个基于<a target="_blank" rel="noopener" href="http://www.baeldung.com/java-asm">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">CGLIB</a>， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong></p>
<p>你需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title class_">Callback</span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span><br><span class="line"><span class="params">                               MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>**obj :**被代理的对象（需要增强的对象）</li>
<li>**method :**被拦截的方法（需要增强的方法）</li>
<li>**args :**方法入参</li>
<li>**methodProxy :**用于调用原始方法</li>
</ol>
<p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p>
<h5 id="CGLIB-动态代理类使用步骤"><a href="#CGLIB-动态代理类使用步骤" class="headerlink" title="CGLIB 动态代理类使用步骤"></a>CGLIB 动态代理类使用步骤</h5><ol>
<li>定义一个类；</li>
<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>
<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>
</ol>
<h5 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h5><p>不同于 JDK 动态代理不需要额外的依赖。<a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">CGLIB</a>(Code Generation Library) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>1.实现一个使用阿里云发送短信的类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliSmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.自定义 <code>MethodInterceptor</code>（方法拦截器）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           代理对象（增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.获取代理类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">DebugMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AliSmsService</span> <span class="variable">aliSmsService</span> <span class="operator">=</span> AliSmsService)CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">aliSmsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure>

<h4 id="JDK-动态代理和-CGLIB-动态代理对比"><a href="#JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理对比"></a>JDK 动态代理和 CGLIB 动态代理对比</h4><ol>
<li><strong>JDK 动态代理只能只能代理实现了接口的类，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>
</ol>
<h3 id="静态代理和动态代理的对比"><a href="#静态代理和动态代理的对比" class="headerlink" title="静态代理和动态代理的对比"></a>静态代理和动态代理的对比</h3><ol>
<li><strong>灵活性 ：</strong>动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，<strong>静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</strong></li>
<li><strong>JVM 层面 ：</strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>这篇文章中主要介绍了代理模式的两种实现：静态代理以及动态代理。涵盖了静态代理和动态代理实战、静态代理和动态代理的区别、JDK 动态代理和 Cglib 动态代理区别等内容。</p>
<h2 id="ZooKeeper常用命令-Curator使用详解"><a href="#ZooKeeper常用命令-Curator使用详解" class="headerlink" title="ZooKeeper常用命令+ Curator使用详解"></a>ZooKeeper常用命令+ Curator使用详解</h2><h3 id="ZooKeeper安装和使用"><a href="#ZooKeeper安装和使用" class="headerlink" title="ZooKeeper安装和使用"></a>ZooKeeper安装和使用</h3><h4 id="使用Docker-安装-ZooKeeper"><a href="#使用Docker-安装-ZooKeeper" class="headerlink" title="使用Docker 安装 ZooKeeper"></a>使用Docker 安装 ZooKeeper</h4><ol>
<li>下载</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull zookeeper:3.5.8</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>运行</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name zookeeper -p 2181:2181 zookeeper:3.5.8</span><br></pre></td></tr></table></figure>

<h4 id="连接ZooKeeper服务"><a href="#连接ZooKeeper服务" class="headerlink" title="连接ZooKeeper服务"></a>连接ZooKeeper服务</h4><ol>
<li>进入Zookeeper容器中</li>
</ol>
<p>先使用 <code>docker ps</code> 查看 ZooKeeper 的 ContainerID，然后使用 <code>docker exec -it ContainerID /bin/bash</code> 命令进入容器中。</p>
<ol start="2">
<li>先进入 bin 目录,然后通过  <code>./zkCli.sh -server 127.0.0.1:2181</code>命令连接ZooKeeper 服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@eaf70fc620cb:/apache-zookeeper-3.5.8-bin<span class="comment"># cd bin</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/1596940060539-7d46c5f0-97cc-4db4-92f4-ed535f224072.png" alt="1596940060539-7d46c5f0-97cc-4db4-92f4-ed535f224072"></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="查看常用命令-help-命令"><a href="#查看常用命令-help-命令" class="headerlink" title="查看常用命令(help 命令)"></a>查看常用命令(help 命令)</h4><p>通过 <code>help</code> 命令查看 ZooKeeper 常用命令</p>
<h4 id="创建节点-create-命令"><a href="#创建节点-create-命令" class="headerlink" title="创建节点(create 命令)"></a>创建节点(create 命令)</h4><p>通过 <code>create</code> 命令在根目录创建了 node1 节点，与它关联的字符串是”node1”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 34] create /node1 “node1”</span><br></pre></td></tr></table></figure>

<p>通过 <code>create</code> 命令在根目录创建了 node1 节点，与它关联的内容是数字 123</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 1] create /node1/node1.1 123</span><br><span class="line">Created /node1/node1.1</span><br></pre></td></tr></table></figure>

<h4 id="更新节点数据内容-set-命令"><a href="#更新节点数据内容-set-命令" class="headerlink" title="更新节点数据内容(set 命令)"></a>更新节点数据内容(set 命令)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 11] set /node1 &quot;set node1&quot;</span><br></pre></td></tr></table></figure>

<h4 id="获取节点的数据-get-命令"><a href="#获取节点的数据-get-命令" class="headerlink" title="获取节点的数据(get 命令)"></a>获取节点的数据(get 命令)</h4><p><code>get</code> 命令可以获取指定节点的数据内容和节点的状态,可以看出我们通过 set 命令已经将节点数据内容改为 “set node1”。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set node1</span><br><span class="line">cZxid = 0x47</span><br><span class="line">ctime = Sun Jan 20 10:22:59 CST 2019</span><br><span class="line">mZxid = 0x4b</span><br><span class="line">mtime = Sun Jan 20 10:41:10 CST 2019</span><br><span class="line">pZxid = 0x4a</span><br><span class="line">cversion = 1</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 9</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure>

<h4 id="查看某个目录下的子节点-ls-命令"><a href="#查看某个目录下的子节点-ls-命令" class="headerlink" title="查看某个目录下的子节点(ls 命令)"></a>查看某个目录下的子节点(ls 命令)</h4><p>通过 <code>ls</code> 命令查看根目录下的节点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 37] ls /</span><br><span class="line">[dubbo, ZooKeeper, node1]</span><br></pre></td></tr></table></figure>

<p>通过 <code>ls</code> 命令查看 node1 目录下的节点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 5] ls /node1</span><br><span class="line">[node1.1]</span><br></pre></td></tr></table></figure>

<p>ZooKeeper 中的 <code>ls</code> 命令和 linux 命令中的 <code>ls</code> 类似， 这个命令将列出绝对路径 path 下的所有子节点信息（列出 1 级，并不递归）</p>
<h4 id="查看节点状态-stat-命令"><a href="#查看节点状态-stat-命令" class="headerlink" title="查看节点状态(stat 命令)"></a>查看节点状态(stat 命令)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 10] stat /node1</span><br><span class="line">cZxid = 0x47</span><br><span class="line">ctime = Sun Jan 20 10:22:59 CST 2019</span><br><span class="line">mZxid = 0x47</span><br><span class="line">mtime = Sun Jan 20 10:22:59 CST 2019</span><br><span class="line">pZxid = 0x4a</span><br><span class="line">cversion = 1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 11</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro.html">ZooKeeper 相关概念总结(入门)</a></p>
<h4 id="查看节点信息和状态-ls2-命令"><a href="#查看节点信息和状态-ls2-命令" class="headerlink" title="查看节点信息和状态(ls2 命令)"></a>查看节点信息和状态(ls2 命令)</h4><p><code>ls2</code> 命令更像是  <code>ls</code> 命令和 <code>stat</code> 命令的结合。 <code>ls2</code> 命令返回的信息包括两部分：</p>
<ol>
<li>子节点列表</li>
<li>当前节点的 stat 信息。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 7] ls2 /node1</span><br><span class="line">[node1.1]</span><br><span class="line">cZxid = 0x47</span><br><span class="line">ctime = Sun Jan 20 10:22:59 CST 2019</span><br><span class="line">mZxid = 0x47</span><br><span class="line">mtime = Sun Jan 20 10:22:59 CST 2019</span><br><span class="line">pZxid = 0x4a</span><br><span class="line">cversion = 1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 11</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure>

<h4 id="删除节点-delete-命令"><a href="#删除节点-delete-命令" class="headerlink" title="删除节点(delete 命令)"></a>删除节点(delete 命令)</h4><p>这个命令很简单，但是需要注意的一点是如果你要删除某一个节点，那么<strong>这个节点必须无子节点</strong>才行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 3] delete /node1/node1.1</span><br></pre></td></tr></table></figure>

<h3 id="ZooKeeper-Java客户端-Curator-简单使用"><a href="#ZooKeeper-Java客户端-Curator-简单使用" class="headerlink" title="ZooKeeper Java客户端 Curator 简单使用"></a>ZooKeeper Java客户端 Curator 简单使用</h3><p>Curator 是Netflix公司开源的一套 ZooKeeper Java客户端框架，相比于 Zookeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/1596940060354-4e3298eb-c56e-427a-9366-f1ecfac4793e.png" alt="1596940060354-4e3298eb-c56e-427a-9366-f1ecfac4793e"></p>
<p>Curator4.0+版本对ZooKeeper 3.5.x支持比较好。开始之前，请先将下面的依赖添加进你的项目。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="连接-ZooKeeper-客户端"><a href="#连接-ZooKeeper-客户端" class="headerlink" title="连接 ZooKeeper 客户端"></a>连接 ZooKeeper 客户端</h4><p>通过 <code>CuratorFrameworkFactory</code> 创建 <code>CuratorFramework</code> 对象，然后再调用  <code>CuratorFramework</code> 对象的 <code>start()</code> 方法即可！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BASE_SLEEP_TIME</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RETRIES</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Retry strategy. Retry 3 times, and will increase the sleep time between retries.</span></span><br><span class="line"><span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(BASE_SLEEP_TIME, MAX_RETRIES);</span><br><span class="line"><span class="type">CuratorFramework</span> <span class="variable">zkClient</span> <span class="operator">=</span> CuratorFrameworkFactory.builder()</span><br><span class="line">    <span class="comment">// the server to connect to (can be a server list)</span></span><br><span class="line">    .connectString(<span class="string">&quot;127.0.0.1:2181&quot;</span>)</span><br><span class="line">    .retryPolicy(retryPolicy)</span><br><span class="line">    .build();</span><br><span class="line">zkClient.start();</span><br></pre></td></tr></table></figure>

<p>对于一些基本参数的说明：</p>
<ul>
<li><code>baseSleepTimeMs:</code>重试之间等待的初始时间</li>
<li><code>maxRetries:</code>最大重试次数</li>
<li><code>connectString:</code>要连接的服务器列表</li>
<li><code>retryPolicy:</code>重试策略</li>
</ul>
<h4 id="数据节点的增删改查"><a href="#数据节点的增删改查" class="headerlink" title="数据节点的增删改查"></a>数据节点的增删改查</h4><h5 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h5><p>我们在 <a target="_blank" rel="noopener" href="https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro/">ZooKeeper常见概念解读</a> 中介绍到，我们通常是将 znode 分为 4 大类：</p>
<ul>
<li><strong>持久（PERSISTENT）节点 ：</strong>一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。</li>
<li><strong>临时（EPHEMERAL）节点 ：</strong>临时节点的生命周期是与 <strong>客户端会话（session）</strong> 绑定的，<strong>会话消失则节点消失</strong> 。并且，临时节点 <strong>只能做叶子节点</strong> ，不能创建子节点。</li>
<li><strong>持久顺序（PERSISTENT_SEQUENTIAL）节点 ：</strong>除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 &#x2F;node1&#x2F;app0000000001 、&#x2F;node1&#x2F;app0000000002 。</li>
<li><strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点 ：</strong>除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li>
</ul>
<p>你在使用的 ZooKeeper 的时候，会发现  <code>CreateMode</code> 类中实际有 7种 <code>znode</code> 类型 ，但是用的最多的还是上面介绍的 4 种。</p>
<ol>
<li>创建持久化节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意:下面的代码会报错，下文说了具体原因</span></span><br><span class="line">zkClient.create().forPath(<span class="string">&quot;/node1/00001&quot;</span>);</span><br><span class="line">zkClient.create().withMode(CreateMode.PERSISTENT).forPath(<span class="string">&quot;/node1/00002&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>但是，你运行上面的代码会报错，这是因为的父节点<code>node1</code>还未创建。</p>
<p>你可以先创建父节点 <code>node1</code> ，然后再执行上面的代码就不会报错了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkClient.create().forPath(<span class="string">&quot;/node1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>更推荐的方式是通过下面这行代码， <code>creatingParentsIfNeeded()</code> <strong>可以保证父节点不存在的时候自动创建父节点，这是非常有用的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(<span class="string">&quot;/node1/00001&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建临时节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">&quot;/node1/00001&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建节点并指定数据内容</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">&quot;/node1/00001&quot;</span>,<span class="string">&quot;java&quot;</span>.getBytes());</span><br><span class="line">zkClient.getData().forPath(<span class="string">&quot;/node1/00001&quot;</span>); <span class="comment">//获取节点的数据内容，获取到的是 byte数组</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>检测节点是否创建成功</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkClient.checkExists().forPath(<span class="string">&quot;/node1/00001&quot;</span>); <span class="comment">//不为null的话，说明节点创建成功</span></span><br></pre></td></tr></table></figure>

<h5 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h5><ol>
<li>删除一个子节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkClient.delete().forPath(<span class="string">&quot;/node1/00001&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>删除一个节点以及其下的所有子节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkClient.delete().deletingChildrenIfNeeded().forPath(<span class="string">&quot;/node1&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="获取-x2F-更新节点数据内容"><a href="#获取-x2F-更新节点数据内容" class="headerlink" title="获取&#x2F;更新节点数据内容"></a>获取&#x2F;更新节点数据内容</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">&quot;/node1/00001&quot;</span>,<span class="string">&quot;java&quot;</span>.getBytes());</span><br><span class="line">zkClient.getData().forPath(<span class="string">&quot;/node1/00001&quot;</span>); <span class="comment">//获取节点的数据内容</span></span><br><span class="line">zkClient.setData().forPath(<span class="string">&quot;/node1/00001&quot;</span>,<span class="string">&quot;c++&quot;</span>.getBytes()); <span class="comment">//更新节点数据内容</span></span><br></pre></td></tr></table></figure>

<h5 id="获取某个节点的所有子节点路径"><a href="#获取某个节点的所有子节点路径" class="headerlink" title="获取某个节点的所有子节点路径"></a>获取某个节点的所有子节点路径</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; childrenPaths = zkClient.getChildren().forPath(<span class="string">&quot;/node1&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><p>下面简单演示一下<strong>如何给某个节点注册子节点监听器</strong> 。注册了监听器之后，这个节点的子节点发生变化比如增加、减少或者更新的时候，你可以自定义回调操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/node1&quot;</span>;</span><br><span class="line"><span class="type">PathChildrenCache</span> <span class="variable">pathChildrenCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathChildrenCache</span>(zkClient, path, <span class="literal">true</span>);</span><br><span class="line"><span class="type">PathChildrenCacheListener</span> <span class="variable">pathChildrenCacheListener</span> <span class="operator">=</span> (curatorFramework, pathChildrenCacheEvent) -&gt; &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line">pathChildrenCache.getListenable().addListener(pathChildrenCacheListener);</span><br><span class="line">pathChildrenCache.start();</span><br></pre></td></tr></table></figure>

<p>如果你要获取节点事件类型的话，可以通过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathChildrenCacheEvent.getType()</span><br></pre></td></tr></table></figure>

<p>一共有下面几种类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">    CHILD_ADDED,<span class="comment">//子节点增加</span></span><br><span class="line">    CHILD_UPDATED,<span class="comment">//子节点更新</span></span><br><span class="line">    CHILD_REMOVED,<span class="comment">//子节点被删除</span></span><br><span class="line">    CONNECTION_SUSPENDED,</span><br><span class="line">    CONNECTION_RECONNECTED,</span><br><span class="line">    CONNECTION_LOST,</span><br><span class="line">    INITIALIZED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Type</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RPC框架代码分析之网络传输模块"><a href="#RPC框架代码分析之网络传输模块" class="headerlink" title="RPC框架代码分析之网络传输模块"></a>RPC框架代码分析之网络传输模块</h2><blockquote>
<p>以下提到的 <strong>服务端</strong> 指的是提供服务&#x2F;方法的一端，<strong>客户端</strong> 指的是调用远程(服务端)服务&#x2F;方法的一端。</p>
</blockquote>
<p>我们之前在“如何自己实现一个 RPC 框架？”这篇文章中介绍到说：<strong>既然我们要调用远程的方法，就要发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务端。</strong> 这就涉及到了网络传输！网络传输具体实现你可以使用 <strong>Socket</strong> （ Java 中最原始、最基础的网络通信方式。但是，Socket 是阻塞 IO、性能低并且功能单一）。你也可以使用同步非阻塞的 I&#x2F;O 模型 <strong>NIO</strong> ，但是用它来进行网络编程真的太麻烦了。不过没关系，你可以使用基于 NIO 的网络编程框架 Netty ，它将是你最好的选择！</p>
<p><strong>网络传输模块整体结构如下：</strong></p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/27ac1c21-ad7d-4fe3-aa7f-ae880b7eeef9.png" alt="27ac1c21-ad7d-4fe3-aa7f-ae880b7eeef9"></p>
<p>一共被分为了 4 个包</p>
<ol>
<li><code>constants:</code> 存放一些网络传输模块共用的常量</li>
<li><code>dto:</code> 用于网络传输的类。</li>
<li><code>handler:</code> 里面只有一个用于处理 rpc 请求的类<code>RpcRequestHandler</code>（根据 rpc 请求调用目标类的目标方法）。</li>
<li><code>transport:</code> 用户网络传输相关类（真正传输网络请求的地方。提供了 Socket 和 Netty 两种网络传输方式）。</li>
</ol>
<h3 id="网络传输实体类"><a href="#网络传输实体类" class="headerlink" title="网络传输实体类"></a>网络传输实体类</h3><p>网络传输实体类在 <code>dto</code> 包下，主要有两个类。</p>
<p><code>RpcRequest.java</code></p>
<p>rpc 请求实体类。当你要调用远程方法的时候，你需要先传输一个 <code>RpcRequest</code> 给对方，<code>RpcRequest</code> 里面包含了要调用的目标方法和类的名称、参数等数据。</p>
<p>另外，<code>version</code> 字段（服务版本）主要是为后续不兼容升级提供可能。<code>group</code> 字段主要用于处理一个接口有多个类实现的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1905122041950251207L</span>;</span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line">    <span class="keyword">private</span> RpcMessageType rpcMessageType;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="keyword">private</span> String group;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RpcServiceProperties <span class="title function_">toRpcProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RpcServiceProperties.builder().serviceName(<span class="built_in">this</span>.getInterfaceName())</span><br><span class="line">                .version(<span class="built_in">this</span>.getVersion())</span><br><span class="line">                .group(<span class="built_in">this</span>.getGroup()).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RpcResponse.java</code></p>
<p>既然有了 rpc 请求实体类，那肯定就要有 rpc 响应实体类了。</p>
<p>当服务端通过 <code>RpcRequest</code> 中的相关数据调用到目标服务的目标方法之后，调用结果就通过 <code>RpcResponse</code> 返回给客户端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcResponse</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">715745410605631233L</span>;</span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * response code</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * response message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * response body</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RpcResponse&lt;T&gt; <span class="title function_">success</span><span class="params">(T data, String requestId)</span> &#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> <span class="title class_">RpcResponse</span>&lt;&gt;();</span><br><span class="line">        response.setCode(RpcResponseCode.SUCCESS.getCode());</span><br><span class="line">        response.setMessage(RpcResponseCode.SUCCESS.getMessage());</span><br><span class="line">        response.setRequestId(requestId);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != data) &#123;</span><br><span class="line">            response.setData(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RpcResponse&lt;T&gt; <span class="title function_">fail</span><span class="params">(RpcResponseCode rpcResponseCode)</span> &#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> <span class="title class_">RpcResponse</span>&lt;&gt;();</span><br><span class="line">        response.setCode(rpcResponseCode.getCode());</span><br><span class="line">        response.setMessage(rpcResponseCode.getMessage());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="网络传输-1"><a href="#网络传输-1" class="headerlink" title="网络传输"></a>网络传输</h3><p><strong>由于，这部分我提供了一种基于 Socket，一种基于 Netty 的网络传输方式（循序渐进）。</strong></p>
<p>因此，我先定义了一个发送 RPC 请求的顶层接口，然后我们分别使用 <strong>Socket</strong> 和 <strong>Netty</strong> 两种方式对这个接口进行实现即可！</p>
<p><code>RpcRequestTransport.java</code> 传输请求的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * send RpcRequest</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RpcRequestTransport</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * send rpc request to server and get result</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rpcRequest message body</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> data from server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">sendRpcRequest</span><span class="params">(RpcRequest rpcRequest)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面，我们先来看一下比较简单点的使用 Socket 进行网络传输的方式。</p>
<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><h5 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h5><p>这里的客户端实际就是发送 RPC 请求的一端，可以对照我们之间画的 RPC 调用的原理图来理解。</p>
<p>客户端主要用于发送网络请求到服务端（目标方法所在的服务器）。当我们知道了服务端的地址之后，我们就可以通过 <code>SocketRpcClient</code> 发送 rpc 请求(<code>RpcRequest</code>) 到服务端了(如果我们要找到服务端的地址，涉及到了注册中心相关的知识。下一节会提到。)。</p>
<p>我们直接实现上面定义的 <code>RpcRequestTransport.java</code> 即可。这样的话，通过 Socket 来传输消息的模块就写好了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于 Socket 传输 RpcRequest</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketRpcClient</span> <span class="keyword">implements</span> <span class="title class_">RpcRequestTransport</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketRpcClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serviceDiscovery = ExtensionLoader.getExtensionLoader(ServiceDiscovery.class).getExtension(<span class="string">&quot;zk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">sendRpcRequest</span><span class="params">(RpcRequest rpcRequest)</span> &#123;</span><br><span class="line">        <span class="comment">// build rpc service name by rpcRequest</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rpcServiceName</span> <span class="operator">=</span> RpcServiceProperties.builder().serviceName(rpcRequest.getInterfaceName())</span><br><span class="line">       .group(rpcRequest.getGroup()).version(rpcRequest.getVersion()).build().toRpcServiceName();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">inetSocketAddress</span> <span class="operator">=</span> serviceDiscovery.lookupService(rpcServiceName);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>()) &#123;</span><br><span class="line">            socket.connect(inetSocketAddress);</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">// Send data to the server through the output stream</span></span><br><span class="line">            objectOutputStream.writeObject(rpcRequest);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(socket.getInputStream());</span><br><span class="line">            <span class="comment">// Read RpcResponse from the input stream</span></span><br><span class="line">            <span class="keyword">return</span> objectInputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;调用服务失败:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h5><p><code>SocketRpcServer.java</code></p>
<p>Socket 服务端。用于等待客户端连接。当客户端成功连接之后，就可以发送 rpc 请求(<code>RpcRequest</code>) 到服务端了。然后，服务端拿到 <code>RpcRequest</code>就会去执行对应的方法。执行完对应的方法之后，就把执行得到的结果放在 <code>RpcResponse</code> 中返回给客户端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketRpcServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketRpcServer</span><span class="params">()</span> &#123;</span><br><span class="line">        threadPool = ThreadPoolFactoryUtils.createCustomThreadPoolIfAbsent(<span class="string">&quot;socket-server-rpc-pool&quot;</span>);</span><br><span class="line">        serviceProvider = SingletonFactory.getInstance(ServiceProviderImpl.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerService</span><span class="params">(Object service)</span> &#123;</span><br><span class="line">        serviceProvider.publishService(service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerService</span><span class="params">(Object service, RpcServiceProperties rpcServiceProperties)</span> &#123;</span><br><span class="line">        serviceProvider.publishService(service, rpcServiceProperties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            server.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(host, PORT));</span><br><span class="line">            CustomShutdownHook.getCustomShutdownHook().clearAll();</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">while</span> ((socket = server.accept()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;client connected [&#123;&#125;]&quot;</span>, socket.getInetAddress());</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> <span class="title class_">SocketRpcRequestHandlerRunnable</span>(socket));</span><br><span class="line">            &#125;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;occur IOException:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Netty-1"><a href="#Netty-1" class="headerlink" title="Netty"></a>Netty</h4><p>Netty 这部分的原理也差不多，不过实现代码差别很大。</p>
<h5 id="客户端-3"><a href="#客户端-3" class="headerlink" title="客户端"></a>客户端</h5><p><code>NettyClient.java</code></p>
<p>Netty 客户端主要提供了:</p>
<ul>
<li><code>doConnect()</code> :用于连接服务端（目标方法所在的服务器）并返回对应的 <code>Channel</code>。当我们知道了服务端的地址之后，我们就可以通过 <code>NettyClient </code>成功连接服务端了。（有了 <code>Channel</code>之后就能发送数据到服务端了）</li>
<li><code>sendRpcRequest()</code> : 用于传输 rpc 请求(<code>RpcRequest</code>) 到服务端。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NettyRpcClient</span> <span class="keyword">implements</span> <span class="title class_">RpcRequestTransport</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelProvider channelProvider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Bootstrap bootstrap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup eventLoopGroup;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">doConnect</span><span class="params">(InetSocketAddress inetSocketAddress)</span> &#123;</span><br><span class="line">        CompletableFuture&lt;Channel&gt; completableFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">        bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;The client has connected [&#123;&#125;] successful!&quot;</span>, inetSocketAddress.toString());</span><br><span class="line">                completableFuture.complete(future.channel());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> completableFuture.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">sendRpcRequest</span><span class="params">(RpcRequest rpcRequest)</span> &#123;</span><br><span class="line">        <span class="comment">// build return value</span></span><br><span class="line">        CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; resultFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// build rpc service name by rpcRequest</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rpcServiceName</span> <span class="operator">=</span> rpcRequest.toRpcProperties().toRpcServiceName();</span><br><span class="line">        <span class="comment">// get server address</span></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">inetSocketAddress</span> <span class="operator">=</span> serviceDiscovery.lookupService(rpcServiceName);</span><br><span class="line">        <span class="comment">// get  server address related channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> getChannel(inetSocketAddress);</span><br><span class="line">        <span class="keyword">if</span> (channel.isActive()) &#123;</span><br><span class="line">            <span class="comment">// put unprocessed request</span></span><br><span class="line">            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);</span><br><span class="line">            <span class="type">RpcMessage</span> <span class="variable">rpcMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcMessage</span>();</span><br><span class="line">            rpcMessage.setData(rpcRequest);</span><br><span class="line">            rpcMessage.setCodec(SerializationTypeEnum.PROTOSTUFF.getCode());</span><br><span class="line">            rpcMessage.setCompress(CompressTypeEnum.GZIP.getCode());</span><br><span class="line">            rpcMessage.setMessageType(RpcConstants.REQUEST_TYPE);</span><br><span class="line">            channel.writeAndFlush(rpcMessage).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;client send message: [&#123;&#125;]&quot;</span>, rpcMessage);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    future.channel().close();</span><br><span class="line">                    resultFuture.completeExceptionally(future.cause());</span><br><span class="line">                    log.error(<span class="string">&quot;Send failed:&quot;</span>, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultFuture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UnprocessedRequests.java</code></p>
<p>用于存放未被服务端处理的请求（建议限制 map 容器大小，避免未处理请求过多 OOM)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnprocessedRequests</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt;&gt; UNPROCESSED_RESPONSE_FUTURES = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String requestId, CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; future)</span> &#123;</span><br><span class="line">        UNPROCESSED_RESPONSE_FUTURES.put(requestId, future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(RpcResponse&lt;Object&gt; rpcResponse)</span> &#123;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; future = UNPROCESSED_RESPONSE_FUTURES.remove(rpcResponse.getRequestId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != future) &#123;</span><br><span class="line">            future.complete(rpcResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NettyClientHandler</code></p>
<p>自定义客户端 <code>ChannelHandler</code> 用于处理服务器发送的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelProvider channelProvider;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NettyClientHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests.class);</span><br><span class="line">        <span class="built_in">this</span>.channelProvider = SingletonFactory.getInstance(ChannelProvider.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取从服务端返回的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;client receive msg: [&#123;&#125;]&quot;</span>, msg);</span><br><span class="line">            <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RpcResponse) &#123;</span><br><span class="line">                RpcResponse&lt;Object&gt; rpcResponse = (RpcResponse&lt;Object&gt;) msg;</span><br><span class="line">                unprocessedRequests.complete(rpcResponse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Netty 心跳机制相关。保证客户端和服务端的连接不被断掉，避免重连。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中，可以看出当 rpc 请求被成功处理（客户端收到服务端的执行结果）之后，我们调用了 <code>unprocessedRequests.complete(rpcResponse)</code> 方法，这样的话，你只需要通过下面的方式就能成功接收到服务端返回的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;RpcResponse&gt; completableFuture = (CompletableFuture&lt;RpcResponse&gt;) clientTransport.sendRpcRequest(rpcRequest);</span><br><span class="line">rpcResponse = completableFuture.get();</span><br></pre></td></tr></table></figure>

<p><code>ChannelProvider.java</code></p>
<p>用于存放 <code>Channel</code>（<code>Channel</code>用于在服务端和客户端之间传输数据）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Channel&gt; channelMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChannelProvider</span><span class="params">()</span> &#123;</span><br><span class="line">        channelMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">get</span><span class="params">(InetSocketAddress inetSocketAddress)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> inetSocketAddress.toString();</span><br><span class="line">        <span class="comment">// determine if there is a connection for the corresponding address</span></span><br><span class="line">        <span class="keyword">if</span> (channelMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelMap.get(key);</span><br><span class="line">            <span class="comment">// if so, determine if the connection is available, and if so, get it directly</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> channel;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channelMap.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(InetSocketAddress inetSocketAddress, Channel channel)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> inetSocketAddress.toString();</span><br><span class="line">        channelMap.put(key, channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(InetSocketAddress inetSocketAddress)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> inetSocketAddress.toString();</span><br><span class="line">        channelMap.remove(key);</span><br><span class="line">        log.info(<span class="string">&quot;Channel map size :[&#123;&#125;]&quot;</span>, channelMap.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务端-3"><a href="#服务端-3" class="headerlink" title="服务端"></a>服务端</h5><p><code>NettyRpcServer.java</code></p>
<p>Netty 服务端。并监听客户端的连接。另外，还提供了两个用户手动注册服务的方法（还可以通过注解<code>RpcService</code>注册服务，这个后面也会介绍到）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyRpcServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">9998</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ServiceProvider</span> <span class="variable">serviceProvider</span> <span class="operator">=</span> SingletonFactory.getInstance(ServiceProviderImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerService</span><span class="params">(Object service, RpcServiceProperties rpcServiceProperties)</span> &#123;</span><br><span class="line">        serviceProvider.publishService(service, rpcServiceProperties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        CustomShutdownHook.getCustomShutdownHook().clearAll();</span><br><span class="line">        <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">DefaultEventExecutorGroup</span> <span class="variable">serviceHandlerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventExecutorGroup</span>(</span><br><span class="line">                RuntimeUtil.cpus() * <span class="number">2</span>,</span><br><span class="line">                ThreadPoolFactoryUtils.createThreadFactory(<span class="string">&quot;service-handler-group&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span></span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">// 是否开启 TCP 底层心跳机制</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">//表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">// 当客户端第一次进行请求的时候才会进行初始化</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">                            <span class="comment">// 30 秒之内没有收到客户端请求的话就关闭连接</span></span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            p.addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">                            p.addLast(<span class="keyword">new</span> <span class="title class_">RpcMessageEncoder</span>());</span><br><span class="line">                            p.addLast(<span class="keyword">new</span> <span class="title class_">RpcMessageDecoder</span>());</span><br><span class="line">                            p.addLast(serviceHandlerGroup, <span class="keyword">new</span> <span class="title class_">NettyRpcServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 绑定端口，同步等待绑定成功</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind(host, PORT).sync();</span><br><span class="line">            <span class="comment">// 等待服务端监听端口关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;occur exception when start server:&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;shutdown bossGroup and workerGroup&quot;</span>);</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            serviceHandlerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NettyServerHandler.java</code></p>
<p>自定义服务端 <code>ChannelHandler</code> 用于处理客户端发送的数据。</p>
<p>当客户端发的 rpc 请求(<code>RpcRequest</code>) 来了之后，服务端就会处理 rpc 请求(<code>RpcRequest</code>) ，处理完之后就把得到 rpc 相应(<code>RpcResponse</code>)传输给客户端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcRequestHandler rpcRequestHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NettyServerHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rpcRequestHandler = SingletonFactory.getInstance(RpcRequestHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取从客户端消息，然后调用目标服务的目标方法并返回给客户端。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">      <span class="comment">// 省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Netty 心跳机制相关。保证客户端和服务端的连接不被断掉，避免重连。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     <span class="comment">// 省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="传输协议-1"><a href="#传输协议-1" class="headerlink" title="传输协议"></a>传输协议</h4><p>简单来说：<strong>通过设计协议，我们定义需要传输哪些类型的数据， 并且还会规定每一种类型的数据应该占多少字节。这样我们在接收到二级制数据之后，就可以正确的解析出我们需要的数据。</strong>这有一点像密文传输的感觉。</p>
<p>以下便是我们设计的传输协议（编解码器这里会用到！！！）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*   <span class="number">0</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>        <span class="number">5</span>     <span class="number">6</span>     <span class="number">7</span>     <span class="number">8</span>         <span class="number">9</span>          <span class="number">10</span>      <span class="number">11</span>     <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>   <span class="number">15</span> <span class="number">16</span></span><br><span class="line">*   +-----+-----+-----+-----+--------+----+----+----+------+-----------+-------+----- --+-----+-----+-------+</span><br><span class="line">*   |   magic   code        |version | full length         | messageType| codec|compress|    RequestId       |</span><br><span class="line">*   +-----------------------+--------+---------------------+-----------+-----------+-----------+------------+</span><br><span class="line">*   |                                                                                                       |</span><br><span class="line">*   |                                         body                                                          |</span><br><span class="line">*   |                                                                                                       |</span><br><span class="line">*   |                                        ... ...                                                        |</span><br><span class="line">*   +-------------------------------------------------------------------------------------------------------+</span><br><span class="line">* 4B  magic code（魔法数）   1B version（版本）   4B full length（消息长度）    1B messageType（消息类型）</span><br><span class="line">* 1B compress（压缩类型） 1B codec（序列化类型）    4B  requestId（请求的Id）</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>魔法数</strong> ： 通常是 4 个字节。这个魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。</li>
<li><strong>序列化器类型</strong> ：标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kyro 等序列化方式。</li>
<li><strong>消息长度</strong> ： 运行时计算出来。</li>
<li>……</li>
</ul>
<h4 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h4><p>编解码器这里主要用到了 Kryo 序列化和反序列化以及 Netty 网络传输字节容器 ByteBuf 相关的知识。</p>
<p>编解码器的作用主要是让我们在 Netty 进行网络传输所用的对象类型 <code>ByteBuf</code> 与 我们代码层面需要的业务对象之间转换。这部分的代码还是比较多的，小伙伴们可以自己阅读以下，整体逻辑还是比较简单的。</p>
<p><strong>一定要先搞懂传输协议之后再去看这部分代码。</strong></p>
<p><code>RpcMessageDecoder.java</code></p>
<p>自定义解码器。负责处理”入站”消息，将 <code>ByteBuf</code> 消息格式的对象转换为我们需要的业务对象。</p>
<blockquote>
<p>网络传输需要通过字节流来实现，ByteBuf 可以看作是 Netty 提供的字节数据的容器，使用它会让我们更加方便地处理字节数据。</p>
</blockquote>
<p><code>RpcMessageEncoder.java</code></p>
<p>自定义编码器。负责处理”出站”消息，将消息格式转换字节数组然后写入到字节数据的容器 <code>ByteBuf</code> 对象中。</p>
<h2 id="RPC框架代码分析之注册中心模块"><a href="#RPC框架代码分析之注册中心模块" class="headerlink" title="RPC框架代码分析之注册中心模块"></a>RPC框架代码分析之注册中心模块</h2><p>我们之前在“如何自己实现一个 RPC 框架？”这篇文章中介绍到说：<strong>注册中心负责服务地址的注册与查找，相当于目录服务</strong>。 服务端启动的时候将服务名称及其对应的地址(ip+port)注册到注册中心，服务消费端根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。</p>
<p><strong>简单来说注册中心就像是一个中转站，提供的作用就是根据调用的服务名称找到远程服务的地址（数据保存服务）。</strong></p>
<p>注册中心模块整体结构如下：</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/1597046857437-3a577559-1fb8-4c6d-ba0b-b0b244dcee6a.png" alt="1597046857437-3a577559-1fb8-4c6d-ba0b-b0b244dcee6a"></p>
<p>我们定义了两个接口 <code>ServiceDiscovery.java</code> 和 <code>ServiceRegistry.java</code>，这两个接口分别定义了服务发现和服务注册行为。</p>
<p><code>ServiceRegistry.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务注册</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServiceRegistry</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册服务到注册中心</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rpcServiceName    完整的服务名称（class name+group+version）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inetSocketAddress 远程服务地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerService</span><span class="params">(String rpcServiceName, InetSocketAddress inetSocketAddress)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ServiceDiscovery.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务发现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServiceDiscovery</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 rpcServiceName 获取远程服务地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rpcServiceName 完整的服务名称（class name+group+version）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 远程服务地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    InetSocketAddress <span class="title function_">lookupService</span><span class="params">(String rpcServiceName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们使用 zookeeper 作为注册中心的实现方式，并实现了这两个接口。</p>
<p><code>ZkServiceRegistry.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务注册（基于zookeeper实现）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkServiceRegistry</span> <span class="keyword">implements</span> <span class="title class_">ServiceRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerService</span><span class="params">(String rpcServiceName, InetSocketAddress inetSocketAddress)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">servicePath</span> <span class="operator">=</span> CuratorUtils.ZK_REGISTER_ROOT_PATH + <span class="string">&quot;/&quot;</span> + rpcServiceName + inetSocketAddress.toString();</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">zkClient</span> <span class="operator">=</span> CuratorUtils.getZkClient();</span><br><span class="line">        CuratorUtils.createPersistentNode(zkClient, servicePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们的服务被注册进 zookeeper 的时候，我们将完整的服务名称 rpcServiceName （class name+group+version）作为根节点 ，子节点是对应的服务地址（ip+端口号）。</p>
<blockquote>
<ul>
<li><code>class name</code> : 服务接口名也就是类名比如：github.javaguide.HelloService。</li>
<li><code>version</code> : 服务版本。主要是为后续不兼容升级提供可能</li>
<li><code>group</code> :服务所在的组。主要用于处理一个接口有多个类实现的情况。</li>
</ul>
</blockquote>
<p>一个根节点（rpcServiceName）可能会对应多个服务地址（相同服务被部署多份的情况）。</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/1597046857469-f43f5087-e095-4ee6-a665-3be3e6a38904.png" alt="1597046857469-f43f5087-e095-4ee6-a665-3be3e6a38904"></p>
<p>如果我们要获得某个服务对应的地址的话，就直接根据完整的服务名称来获取到其下的所有子节点，然后通过具体的负载均衡策略取出一个就可以了。相关代码如下在 <code>ZkServiceDiscovery.java</code>中已经给出。</p>
<p><code>ZkServiceDiscovery.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务发现（基于zookeeper实现）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkServiceDiscovery</span> <span class="keyword">implements</span> <span class="title class_">ServiceDiscovery</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoadBalance loadBalance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZkServiceDiscovery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadBalance = <span class="keyword">new</span> <span class="title class_">RandomLoadBalance</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InetSocketAddress <span class="title function_">lookupService</span><span class="params">(String rpcServiceName)</span> &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">zkClient</span> <span class="operator">=</span> CuratorUtils.getZkClient();</span><br><span class="line">        List&lt;String&gt; serviceUrlList = CuratorUtils.getChildrenNodes(zkClient, rpcServiceName);</span><br><span class="line">        <span class="keyword">if</span> (serviceUrlList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcErrorMessage.SERVICE_CAN_NOT_BE_FOUND, rpcServiceName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// load balancing</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">targetServiceUrl</span> <span class="operator">=</span> loadBalance.selectServiceAddress(serviceUrlList);</span><br><span class="line">        log.info(<span class="string">&quot;Successfully found the service address:[&#123;&#125;]&quot;</span>, targetServiceUrl);</span><br><span class="line">        String[] socketAddressArray = targetServiceUrl.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> socketAddressArray[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> Integer.parseInt(socketAddressArray[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(host, port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们根据完整的服务名称便可以将对应的服务地址查出来， 查出来的服务地址可能并不止一个。</p>
<p>所以，我们可以通过对应的负载均衡策略来选择出一个服务地址。</p>
<p><code>CuratorUtils.java</code></p>
<p>另外，我们还自定义了一个 ZooKeeper Java 客户端 Curtor 的工具类 <code>CuratorUtils.java</code> 。关于这个工具类，这里就不再提了。</p>
<p>在《08 Zookeeper 常用命令+ Curtor 使用详解》中已经介绍的非常详细了。</p>
<h2 id="RPC-框架代码分析之其他模块"><a href="#RPC-框架代码分析之其他模块" class="headerlink" title="RPC 框架代码分析之其他模块"></a>RPC 框架代码分析之其他模块</h2><h3 id="动态代理屏蔽网络传输细节"><a href="#动态代理屏蔽网络传输细节" class="headerlink" title="动态代理屏蔽网络传输细节"></a>动态代理屏蔽网络传输细节</h3><p>我们在前面的章节讲到过我们需要用到动态代理来屏蔽复杂的网络传输细节。对应的代码: <code>RpcClientProxy.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;clazz&#125;, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们去调用一个远程的方法的时候，实际上是通过代理对象调用的。</p>
<p>获取代理对象的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;clazz&#125;, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网络传输细节都被封装在了  <code>invoke()</code>  方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;invoked method: [&#123;&#125;]&quot;</span>, method.getName());</span><br><span class="line">    <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> RpcRequest.builder().methodName(method.getName())</span><br><span class="line">            .parameters(args)</span><br><span class="line">            .interfaceName(method.getDeclaringClass().getName())</span><br><span class="line">            .paramTypes(method.getParameterTypes())</span><br><span class="line">            .requestId(UUID.randomUUID().toString())</span><br><span class="line">            .group(rpcServiceProperties.getGroup())</span><br><span class="line">            .version(rpcServiceProperties.getVersion())</span><br><span class="line">            .build();</span><br><span class="line">    RpcResponse&lt;Object&gt; rpcResponse = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (rpcRequestTransport <span class="keyword">instanceof</span> NettyRpcClient) &#123;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; completableFuture = (CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt;) rpcRequestTransport.sendRpcRequest(rpcRequest);</span><br><span class="line">        rpcResponse = completableFuture.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rpcRequestTransport <span class="keyword">instanceof</span> SocketRpcClient) &#123;</span><br><span class="line">        rpcResponse = (RpcResponse&lt;Object&gt;) rpcRequestTransport.sendRpcRequest(rpcRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.check(rpcResponse, rpcRequest);</span><br><span class="line">    <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过注解注册-x2F-消费服务"><a href="#通过注解注册-x2F-消费服务" class="headerlink" title="通过注解注册&#x2F;消费服务"></a>通过注解注册&#x2F;消费服务</h3><p>我们这里借用了 Spring 容器相关的功能。核心代码都放在了 ： <code>src/main/java/github/javaguide/spring</code>  包下面。</p>
<p>我们定义两个注解：</p>
<ul>
<li><code>RcpService</code>  ：注册服务</li>
<li><code>RpcReference</code>  ：消费服务</li>
</ul>
<p><code>RcpService.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service version, default value is empty string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">version</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service group, default value is empty string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">group</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RpcReference.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcReference &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service version, default value is empty string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">version</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service group, default value is empty string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">group</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说一下原理。</p>
<p>我们实现需要 <code>BeanPostProcessor</code> 接口并重写 <code>postProcessBeforeInitialization()</code>方法和 <code>postProcessAfterInitialization()</code> 方法。</p>
<p>Spring bean 在<strong>实例化之前</strong>会调用 <code>postProcessBeforeInitialization()</code>方法，在 Spring bean <strong>实例化之后</strong>会调用  <code>postProcessAfterInitialization()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被我们使用 <code>RpcService</code>和<code>RpcReference</code> 注解的类都算是 Spring Bean。</p>
<ul>
<li>我们可以在<code>postProcessBeforeInitialization()</code>方法中去判断类上是否有<code>RpcService</code> 注解。如果有的话，就取出 <code>group</code> 和 <code>version</code> 的值。然后，再调用 <code>ServiceProvider</code> 的 <code>publishService()</code> 方法发布服务即可！</li>
<li>我们可以在 <code>postProcessAfterInitialization()</code> 方法中遍历类的属性上是否有  <code>RpcReference</code> 注解。如果有的话，我们就通过反射将这个属性赋值即可！</li>
</ul>
<h2 id="（优化）使用CompletableFuture优化接受服务提供端返回结果"><a href="#（优化）使用CompletableFuture优化接受服务提供端返回结果" class="headerlink" title="（优化）使用CompletableFuture优化接受服务提供端返回结果"></a>（优化）使用CompletableFuture优化接受服务提供端返回结果</h2><h3 id="使用-AttributeMap-接受服务端返回结果"><a href="#使用-AttributeMap-接受服务端返回结果" class="headerlink" title="使用 AttributeMap 接受服务端返回结果"></a>使用 AttributeMap 接受服务端返回结果</h3><p>最开始的时候是通过 <code>AttributeMap</code> 绑定到Channel上实现的，相关代码如下：</p>
<p><code>NettyClientTransport.java</code>（用来发送 RpcRequest 请求）</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/1597058614646-de6c89f2-60f4-4e26-82f6-efaf9c01f581.png" alt="1597058614646-de6c89f2-60f4-4e26-82f6-efaf9c01f581"></p>
<p><code>NettyClientHandler.java</code> （自定义客户端 ChannelHandler 来处理服务端发过来的数据）</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/1597058614610-286cc9cd-1c6e-4a3d-95c0-8a4c02ffc5ac.png" alt="1597058614610-286cc9cd-1c6e-4a3d-95c0-8a4c02ffc5ac"></p>
<p>这种是实现的缺点是不清晰，而且你每次都要调用 <code>channel.closeFuture().sync();</code> 阻塞来手动等待请求返回。</p>
<h3 id="使用-CompletableFuture-进行优化"><a href="#使用-CompletableFuture-进行优化" class="headerlink" title="使用 CompletableFuture 进行优化"></a>使用 CompletableFuture 进行优化</h3><p>通过<code>CompletableFuture</code>包装返回结果，对代码进行了重构，重要部分的代码如下：</p>
<p><code>NettyClientTransport.java</code>（用来发送 RpcRequest 请求）</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/1597058614624-83b8b500-4b86-4438-b458-8abd47b18c58.png" alt="1597058614624-83b8b500-4b86-4438-b458-8abd47b18c58"></p>
<p><code>NettyClientHandler.java</code> （自定义客户端 ChannelHandler 来处理服务端发过来的数据）</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/1597058614600-6c2038dd-8b65-480e-9d83-4d5d7dd156e3.png" alt="1597058614600-6c2038dd-8b65-480e-9d83-4d5d7dd156e3"></p>
<p><code>UnprocessedRequests.java</code> 存放了未处理的请求（建议限制 map 容器大小，避免未处理请求过多 OOM</p>
<p><img src="/img/loading.gif" data-original="/../images/%E5%90%8E%E7%AB%AF/RPC/1597058614601-72be49db-42b4-46b6-9dfc-c6420b9d5a3e.png" alt="1597058614601-72be49db-42b4-46b6-9dfc-c6420b9d5a3e"></p>
<p>现在只需要通过下面的方式就能成功接收到服务端返回的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;RpcResponse&gt; completableFuture = (CompletableFuture&lt;RpcResponse&gt;) clientTransport.sendRpcRequest(rpcRequest);</span><br><span class="line">rpcResponse = completableFuture.get();</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://byurself.github.io/">byu_rself</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://byurself.github.io/byu_rself/58d29a67.html">https://byurself.github.io/byu_rself/58d29a67.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://byurself.github.io" target="_blank">byu_rself</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RPC/">RPC</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/byu_rself/79d7e662.html" title="LC.P1027[最长等差数列]"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LC.P1027[最长等差数列]</div></div></a></div><div class="next-post pull-right"><a href="/byu_rself/ea714bf1.html" title="LC.P854[相似度为 K 的字符串]"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LC.P854[相似度为 K 的字符串]</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">byu_rself</div><div class="author-info__description">努力努力！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">577</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">104</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/byurself"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RPC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8E%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98"><span class="toc-number">1.</span> <span class="toc-text">RPC学习笔记与项目实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">RPC简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是RPC？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">RPC原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81RPC%E6%A1%86%E6%9E%B6"><span class="toc-number">1.2.</span> <span class="toc-text">常见RPC框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo"><span class="toc-number">1.2.1.</span> <span class="toc-text">Dubbo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Motan"><span class="toc-number">1.2.2.</span> <span class="toc-text">Motan</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gRPC"><span class="toc-number">1.2.3.</span> <span class="toc-text">gRPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thirft"><span class="toc-number">1.2.4.</span> <span class="toc-text">Thirft</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AARPC%E6%A1%86%E6%9E%B6"><span class="toc-number">1.3.</span> <span class="toc-text">如何自己实现一个RPC框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AARPC%E6%A1%86%E6%9E%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text">如何自己设计一个RPC框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">注册中心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">网络传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">序列化和反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">负载均衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">传输协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84-RPC-%E6%A1%86%E6%9E%B6%E9%9C%80%E8%A6%81%E5%93%AA%E4%BA%9B%E6%8A%80%E6%9C%AF"><span class="toc-number">1.3.2.</span> <span class="toc-text">实现一个最基本的 RPC 框架需要哪些技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">Java</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">Netty</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Zookeeper"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">Zookeeper</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.3.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE%E9%80%89%E6%8B%A9"><span class="toc-number">1.4.</span> <span class="toc-text">序列化介绍以及序列化协议选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.4.1.</span> <span class="toc-text">什么是序列化和反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.4.2.</span> <span class="toc-text">常见的序列化协议有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK%E8%87%AA%E5%B8%A6%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">JDK自带的序列化方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kyro"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">Kyro</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Protobuf"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">Protobuf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ProtoStuff"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">ProtoStuff</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hessian"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">Hessian</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.4.3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB"><span class="toc-number">1.4.4.</span> <span class="toc-text">推荐阅读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98"><span class="toc-number">1.5.</span> <span class="toc-text">Socket网络通信实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSocket-%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">1.5.1.</span> <span class="toc-text">什么是Socket(套接字)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket%E7%BD%91%E8%B7%AF%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">Socket网路通信过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98-1"><span class="toc-number">1.6.1.</span> <span class="toc-text">Socket网络通信实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">客户端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98"><span class="toc-number">1.7.</span> <span class="toc-text">Netty从入门到网络通信实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.7.1.</span> <span class="toc-text">Netty介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E7%89%B9%E7%82%B9"><span class="toc-number">1.7.2.</span> <span class="toc-text">Netty特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">1.7.3.</span> <span class="toc-text">Netty能做什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%94%A8%E5%88%B0%E4%BA%86Netty"><span class="toc-number">1.7.4.</span> <span class="toc-text">哪些开源项目用到了Netty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty-%E4%BD%BF%E7%94%A8-Kryo-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1%E5%AE%9E%E6%88%98"><span class="toc-number">1.7.5.</span> <span class="toc-text">Netty 使用 Kryo 序列化传输对象实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">传输实体类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82"><span class="toc-number">1.7.5.1.1.</span> <span class="toc-text">客户端请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%93%8D%E5%BA%94"><span class="toc-number">1.7.5.1.2.</span> <span class="toc-text">服务器端响应</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-1"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.7.5.2.1.</span> <span class="toc-text">初始化客户端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-ChannelHandler-%E5%A4%84%E7%90%86%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B6%88%E6%81%AF"><span class="toc-number">1.7.5.2.2.</span> <span class="toc-text">自定义 ChannelHandler 处理服务端消息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-1"><span class="toc-number">1.7.5.3.</span> <span class="toc-text">服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">1.7.5.3.1.</span> <span class="toc-text">初始化服务端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-ChannelHandler-%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B6%88%E6%81%AF"><span class="toc-number">1.7.5.3.2.</span> <span class="toc-text">自定义 ChannelHandler 处理客户端消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8"><span class="toc-number">1.7.6.</span> <span class="toc-text">编码器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E7%A0%81%E5%99%A8"><span class="toc-number">1.7.6.1.</span> <span class="toc-text">自定义编码器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">1.7.6.2.</span> <span class="toc-text">自定义解码器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.7.6.3.</span> <span class="toc-text">自定义序列化接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.7.6.4.</span> <span class="toc-text">实现序列化接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C"><span class="toc-number">1.7.7.</span> <span class="toc-text">测试效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-JDK-x2F-CGLIB-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98"><span class="toc-number">1.8.</span> <span class="toc-text">静态代理+JDK&#x2F;CGLIB 动态代理实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.1.</span> <span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.8.2.</span> <span class="toc-text">静态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-1"><span class="toc-number">1.8.3.</span> <span class="toc-text">动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">JDK 动态代理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.8.3.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.8.3.1.2.</span> <span class="toc-text">JDK 动态代理类使用步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.8.3.1.3.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">CGLIB动态代理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">1.8.3.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CGLIB-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.8.3.2.2.</span> <span class="toc-text">CGLIB 动态代理类使用步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.8.3.2.3.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C-CGLIB-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AF%B9%E6%AF%94"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">JDK 动态代理和 CGLIB 动态代理对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.8.4.</span> <span class="toc-text">静态代理和动态代理的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">1.8.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZooKeeper%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-Curator%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.9.</span> <span class="toc-text">ZooKeeper常用命令+ Curator使用详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ZooKeeper%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">1.9.1.</span> <span class="toc-text">ZooKeeper安装和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Docker-%E5%AE%89%E8%A3%85-ZooKeeper"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">使用Docker 安装 ZooKeeper</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5ZooKeeper%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">连接ZooKeeper服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.9.2.</span> <span class="toc-text">常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-help-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">查看常用命令(help 命令)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9-create-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">创建节点(create 命令)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E5%86%85%E5%AE%B9-set-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">更新节点数据内容(set 命令)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E6%8D%AE-get-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.9.2.4.</span> <span class="toc-text">获取节点的数据(get 命令)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E5%AD%90%E8%8A%82%E7%82%B9-ls-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.9.2.5.</span> <span class="toc-text">查看某个目录下的子节点(ls 命令)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%8A%82%E7%82%B9%E7%8A%B6%E6%80%81-stat-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.9.2.6.</span> <span class="toc-text">查看节点状态(stat 命令)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF%E5%92%8C%E7%8A%B6%E6%80%81-ls2-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.9.2.7.</span> <span class="toc-text">查看节点信息和状态(ls2 命令)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9-delete-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.9.2.8.</span> <span class="toc-text">删除节点(delete 命令)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZooKeeper-Java%E5%AE%A2%E6%88%B7%E7%AB%AF-Curator-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">1.9.3.</span> <span class="toc-text">ZooKeeper Java客户端 Curator 简单使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5-ZooKeeper-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">连接 ZooKeeper 客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">数据节点的增删改查</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9"><span class="toc-number">1.9.3.2.1.</span> <span class="toc-text">创建节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">1.9.3.2.2.</span> <span class="toc-text">删除节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-x2F-%E6%9B%B4%E6%96%B0%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E5%86%85%E5%AE%B9"><span class="toc-number">1.9.3.2.3.</span> <span class="toc-text">获取&#x2F;更新节点数据内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%90%E8%8A%82%E7%82%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">1.9.3.2.4.</span> <span class="toc-text">获取某个节点的所有子节点路径</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">监听器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%9D%97"><span class="toc-number">1.10.</span> <span class="toc-text">RPC框架代码分析之网络传输模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">1.10.1.</span> <span class="toc-text">网络传输实体类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93-1"><span class="toc-number">1.10.2.</span> <span class="toc-text">网络传输</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Socket"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-2"><span class="toc-number">1.10.2.1.1.</span> <span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-2"><span class="toc-number">1.10.2.1.2.</span> <span class="toc-text">服务端</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty-1"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">Netty</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-3"><span class="toc-number">1.10.2.2.1.</span> <span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-3"><span class="toc-number">1.10.2.2.2.</span> <span class="toc-text">服务端</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-1"><span class="toc-number">1.10.2.3.</span> <span class="toc-text">传输协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">1.10.2.4.</span> <span class="toc-text">编解码器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="toc-number">1.11.</span> <span class="toc-text">RPC框架代码分析之注册中心模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC-%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97"><span class="toc-number">1.12.</span> <span class="toc-text">RPC 框架代码分析之其他模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%B1%8F%E8%94%BD%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E7%BB%86%E8%8A%82"><span class="toc-number">1.12.1.</span> <span class="toc-text">动态代理屏蔽网络传输细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%B3%A8%E8%A7%A3%E6%B3%A8%E5%86%8C-x2F-%E6%B6%88%E8%B4%B9%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.12.2.</span> <span class="toc-text">通过注解注册&#x2F;消费服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BC%98%E5%8C%96%EF%BC%89%E4%BD%BF%E7%94%A8CompletableFuture%E4%BC%98%E5%8C%96%E6%8E%A5%E5%8F%97%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E7%AB%AF%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="toc-number">1.13.</span> <span class="toc-text">（优化）使用CompletableFuture优化接受服务提供端返回结果</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-AttributeMap-%E6%8E%A5%E5%8F%97%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="toc-number">1.13.1.</span> <span class="toc-text">使用 AttributeMap 接受服务端返回结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-CompletableFuture-%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="toc-number">1.13.2.</span> <span class="toc-text">使用 CompletableFuture 进行优化</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/byu_rself/ae350545.html" title="LC.P2834[找出美丽数组的最小和]">LC.P2834[找出美丽数组的最小和]</a><time datetime="2024-03-08T02:03:04.000Z" title="发表于 2024-03-08 10:03:04">2024-03-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/byu_rself/adc29c6b.html" title="LC.P2575[找出字符串的可整除数组]">LC.P2575[找出字符串的可整除数组]</a><time datetime="2024-03-07T01:58:29.000Z" title="发表于 2024-03-07 09:58:29">2024-03-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/byu_rself/25b267ab.html" title="LC.P2917[找出数组中的K-or值]">LC.P2917[找出数组中的K-or值]</a><time datetime="2024-03-06T01:46:49.000Z" title="发表于 2024-03-06 09:46:49">2024-03-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/byu_rself/bd9bb3a9.html" title="LC.P232[用栈实现队列]">LC.P232[用栈实现队列]</a><time datetime="2024-03-04T01:57:35.000Z" title="发表于 2024-03-04 09:57:35">2024-03-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/byu_rself/84c63bb0.html" title="LC.P225[用队列实现栈]">LC.P225[用队列实现栈]</a><time datetime="2024-03-04T01:51:30.000Z" title="发表于 2024-03-04 09:51:30">2024-03-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By byu_rself</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://byurself.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'vDBwmLbCoeDXzg0h3RPXJceo-gzGzoHsz',
      appKey: 'ULAbVvd0pULg0jSSKwuam8ed',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>